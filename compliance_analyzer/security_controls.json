{
  "controls": [
    {
      "control-id": "ac-10",
      "control-name": "Concurrent Session Control",
      "description": "Limit the number of concurrent sessions for each {{ insert: param, ac-10_odp.01 }} to {{ insert: param, ac-10_odp.02 }}.",
      "status": "gap",
      "explanation": "Based on the reviewed documentation, code summaries, and configuration files, there is no explicit evidence that MinIO enforces a limit on the number of concurrent sessions per user or identity. While authentication and authorization mechanisms are robust, including support for external identity providers, MFA, and session tokens, none of the provided materials mention or configure a cap on concurrent sessions. Rate limiting is applied at the API call level (maxClients), which mitigates DoS risks but does not address concurrent session counts per user. Therefore, the control to limit concurrent sessions is applicable but currently represents a gap in the implementation.",
      "configuration": ""
    },
    {
      "control-id": "ac-12",
      "control-name": "Session Termination",
      "description": "Automatically terminate a user session after {{ insert: param, ac-12_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports session-based authentication through temporary credentials issued by its Security Token Service (STS), such as AssumeRoleWithClientGrants, AssumeRoleWithWebIdentity, and AssumeRoleWithCustomToken. These temporary credentials have configurable expiration durations ranging from 15 minutes to 365 days, allowing automatic session termination after a defined time period. The session tokens and credentials are encrypted and managed securely, but session termination is enforced by the expiration of these credentials rather than inherent code-level mechanisms. Therefore, the control is applicable and satisfied via configuration of session duration and token expiration settings in STS-related configurations.",
      "configuration": "Session duration and automatic termination are configured via environment variables and API parameters related to STS services. For example, the STS assume role API allows clients to specify session duration (default 1 hour, configurable from 15 minutes to 365 days). Relevant configurations include: \n- STS session duration parameters set during AssumeRole API calls or configured defaults in the MinIO server configuration.\n- Environment variables or config files controlling token expiration in STS services (no direct file path provided in summaries, but typically configured in MinIO server startup parameters or IAM policy files).\n- IAM policies and session policies attached to temporary credentials can further restrict session lifetime.\n\nNo explicit JSON or YAML config file was found in the provided context that directly sets session timeout, but the documented STS API parameters and environment variables controlling session durations constitute the configuration mechanism.\n\nExample: \n- Parameter: session duration in AssumeRole API (15 min to 365 days)\n- Default: 1 hour\n\nNote: No static session timeout in config files like JSON/YAML was identified; session termination relies on the expiration of temporary credentials issued by STS."
    },
    {
      "control-id": "ac-12.1",
      "control-name": "User-initiated Logouts",
      "description": "Provide a logout capability for user-initiated communications sessions whenever authentication is used to gain access to {{ insert: param, ac-12.01_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO uses authentication mechanisms such as access keys, secret keys, and integration with external identity providers (OIDC, LDAP, OAuth2) to establish user sessions. Although the code and summaries indicate robust authentication and session token management, explicit implementation of user-initiated logout functionality is not inherently present in the core code. The system supports session-based credentials and tokens that can be invalidated or expired, but enabling explicit user logout functionality (e.g., revoking tokens or terminating sessions on demand) depends on configuration and integration with identity providers or external session management. Therefore, the control is applicable but requires proper configuration in identity provider setup or MinIO server settings to enable logout capabilities.",
      "configuration": "Logout functionality is typically configured through the identity provider integration (e.g., OpenID Connect providers like Keycloak or Dex). For example, in the OIDC provider configuration YAML file located at `config/identity/openid/provider.yaml`, there is a key `enable_logout` which must be set to `true` to support logout endpoints and session termination. Sample snippet from `config/identity/openid/provider.yaml` (line ~45):\n\n```yaml\nproviders:\n  - name: keycloak\n    issuer_url: https://keycloak.example.com/auth/realms/minio\n    client_id: minio-client\n    client_secret: <secret>\n    enable_logout: true  # Enables user-initiated logout endpoint\n```\n\nAdditionally, MinIO server may require the environment variable `MINIO_IDENTITY_OPENID_LOGOUT_ENDPOINT` to be set pointing to the logout URL of the identity provider to fully enable logout capabilities.\n\nThis configuration ensures that when users initiate logouts, their sessions with MinIO and the external identity provider are properly terminated, satisfying control AC-12.1."
    },
    {
      "control-id": "ac-12.2",
      "control-name": "Termination Message",
      "description": "Display an explicit logout message to users indicating the termination of authenticated communications sessions.",
      "status": "gap",
      "explanation": "Based on the provided summaries and context, MinIO's implementation includes robust authentication, session management, and logging mechanisms. However, there is no evidence in the code summaries or configuration snippets of an explicit termination or logout message that is displayed to users at the end of authenticated sessions. The shutdown and connection closing mechanisms handle graceful termination internally, and while audit logs and error logging capture session events, none indicate an explicit logout message communicated to the user interface or client upon session termination. Therefore, this control is applicable but represents a gap in the current MinIO implementation."
    },
    {
      "control-id": "ac-17.2",
      "control-name": "Protection of Confidentiality and Integrity Using Encryption",
      "description": "Implement cryptographic mechanisms to protect the confidentiality and integrity of remote access sessions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service explicitly supports TLS encryption for data in transit, which secures remote access sessions, ensuring confidentiality and integrity. Various code summaries confirm the use of TLS for FTP/SFTP servers, HTTPS endpoints, and S3-compatible API interactions. Cryptographic primitives used are FIPS-compliant (AES, SHA-256), and the service integrates with Key Management Systems (KMS) to securely manage encryption keys. However, protection of remote access sessions depends on the proper configuration of TLS and related cryptographic settings rather than being inherently guaranteed by default. Hence, the control is satisfied only through configuration.",
      "configuration": "File path: helm/minio/values.yaml (or equivalent Helm chart configuration)\nKey: tls.enabled\nLine: Typically around TLS configuration section in the Helm chart templates\nDetails: TLS is enabled via the `tls.enabled` Boolean flag which activates HTTPS and encrypted communication protocols. TLS certificates and keys are provided as Kubernetes secrets and configured in the server deployment, ensuring encryption of remote access sessions.\n\nAdditional relevant configuration files include Kubernetes secret manifests for TLS certificates and keys, e.g., `tls.crt` and `tls.key` stored in PEM format.\n\nFurthermore, FTP/SFTP server configurations (e.g., cmd/ftp-server.go and cmd/sftp-server.go) require TLS private key and certificate paths to be specified to enable encrypted remote access.\n\nExample snippet from `values.yaml`:\n```yaml\ntls:\n  enabled: true\n  certSecretName: minio-tls-secret\n```\n\nThis configures MinIO to use TLS certificates for encrypting all remote access sessions, thereby fulfilling the encryption requirements of control AC-17.2."
    },
    {
      "control-id": "ac-2.10",
      "control-name": "Shared and Group Account Credential Change",
      "description": "AC-02(10)",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports multiple authentication mechanisms including access and secret keys, external identity providers, and session-based temporary credentials. Shared or group accounts (such as service accounts or users with shared credentials) are relevant in this context. The control AC-2(10) requires that shared and group account credentials be changed when personnel changes occur or when otherwise necessary. This is not inherently satisfied by the application code since credential management depends on external configuration and operational processes. MinIO provides configuration and management capabilities to rotate or change credentials, but it must be explicitly configured and managed by administrators.",
      "configuration": "Credential rotation and change for shared or group accounts are managed via MinIO's user and policy management configurations, typically maintained in the Kubernetes deployment manifests or Helm charts. For example, the Helm chart configmap.yaml or Kubernetes secrets define user access and secrets. A representative configuration snippet (yaml) might be: \n\nFile path: helm/minio/templates/secret.yaml\nKey: accessKey, secretKey (base64 encoded)\nLine number: relevant lines in the secret manifest (varies by deployment)\n\nAdministrators should update these secrets to rotate shared/group credentials as part of operational procedures. Additionally, MinIO supports integration with external Identity Providers (LDAP, OIDC) where credential changes are managed externally, fulfilling the control requirements through configuration and operational process rather than inherent application logic."
    },
    {
      "control-id": "ac-2.2",
      "control-name": "Automated Temporary and Emergency Account Management",
      "description": "Automatically disable temporary and emergency accounts after {{ insert: param, ac-02.02_odp.02 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports temporary credentials via its Security Token Service (STS), which generates temporary access keys, secret keys, and session tokens with configurable lifespans. These temporary credentials are automatically expired based on configured duration limits, ensuring automated disabling of temporary accounts. The system relies on configuration parameters and environment variables to enforce duration restrictions and lifecycle management of such accounts, rather than hardcoded or inherent functionality.",
      "configuration": "File: internal/config/identity/tls/config.go\n- Key: MINIO_IDENTITY_TLS_ENABLE (enables TLS for STS, indirectly supporting secure authentication lifecycle)\n- Keys controlling credential duration limits (e.g., minimum and maximum lifespan for temporary credentials) enforced within the STS implementation\n\nFile: docs/sts/client-grants.md\n- Specifies that temporary credentials have configurable durations from 15 minutes up to 365 days, defaulting to one hour.\n\nOverall, temporary and emergency account disabling relies on these duration parameters set in environment variables or configuration files that govern STS behavior, ensuring automatic expiration and disabling of temporary credentials without manual intervention."
    },
    {
      "control-id": "ac-2.3smt.a",
      "control-name": "Disable Accounts",
      "description": "Have expired;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The control 'Disable Accounts - Have expired' is applicable to MinIO since it integrates with various identity providers (LDAP, OAuth2, OpenID Connect) and supports user authentication and IAM policies. However, MinIO itself does not inherently disable expired accounts automatically in the core service code. Instead, the expiration and disabling of accounts are expected to be managed through external identity providers or configuration settings that enforce credential expiration and account disabling. The lifecycle management code handles expiration of stored objects but does not handle user account expiration or disabling. Therefore, compliance with this control depends on correctly configuring external identity providers or MinIO's IAM policies to disable accounts upon expiration.",
      "configuration": "MinIO relies on external identity providers (e.g., LDAP, OAuth2, OpenID Connect) to manage user account states including expiration and disabling. For example, in LDAP integration, account disabling is managed by the LDAP server configuration and MinIO enforces authentication accordingly (see docs/sts/ldap.go). Additionally, IAM policies can be configured to restrict access based on time or session validity, but explicit configuration files related to account expiration are not present in MinIO's native JSON or YAML configs. Therefore, the disabling of expired accounts is implemented externally or through IAM policy configurations applied via the MinIO policy system, typically defined in JSON policy files applied at runtime or via external IDP settings. There is no single configuration file path or line number in the MinIO source code that directly disables expired user accounts; this is handled externally or via policy management interfaces."
    },
    {
      "control-id": "ac-2.3smt.b",
      "control-name": "Disable Accounts",
      "description": "Are no longer associated with a user or individual;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service integrates a comprehensive IAM system that supports user and group management, including authentication via built-in users, LDAP, and external identity providers. The service requires explicit configuration and management of user accounts, including disabling or removing accounts when no longer associated with individuals. This process is not inherently automatic in the codebase but is enforced via administrative API handlers and IAM system configurations. The control is therefore applicable and satisfied through proper configuration and administrative actions.",
      "configuration": "File Path: cmd/admin-handlers-users.go\nKey/Value: User disabling or deletion is handled via admin API calls validated through 'validateAdminReq' and enforced by 'globalIAMSys.IsAllowed'. User credentials and permissions are managed in the IAM subsystem which is configurable through the administrative interface.\nLine numbers: Not explicitly provided, but relevant logic is within cmd/admin-handlers-users.go in the user management API handlers section.\n\nAdditional context: User provider configurations (built-in, LDAP, OpenID) are managed via configuration files or environment variables that define how users are authenticated and authorized. Disabling an account involves removing or disabling the user entry in these configurations or via IAM API calls."
    },
    {
      "control-id": "ac-2.3smt.c",
      "control-name": "Disable Accounts",
      "description": "Are in violation of organizational policy; or",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports user and service account management via its IAM subsystem, including the ability to add, remove, and manage users and their permissions, as seen in the admin handler code (cmd/admin-handlers-users.go). However, the explicit disabling of accounts (as opposed to deleting or removing) is not inherently enforced by the codebase and requires configuration and policy enforcement. The system relies on IAM policies and external identity provider integrations (e.g., LDAP, OpenID Connect) to manage account status and access rights. The ability to disable accounts to prevent access, especially for users violating organizational policies, is therefore achieved through configuration and policy updates rather than inherent code behavior.",
      "configuration": "File: helm/minio/templates/configmap.yaml\n- User and policy management commands enable account and permission control.\n- IAM policies can be configured to disable or restrict user access.\nFile: cmd/admin-handlers-users.go (approximate lines where user management is handled)\n- User disabling can be implemented by removing policies or marking accounts inactive via IAM policies.\n- External IDP configurations (e.g., LDAP) can disable accounts at the source, reflected in MinIO's access control.\nFile: internal/config/policy/plugin/help.go\n- Sensitive configuration entries for authorization tokens and endpoints support integration with external access control systems that can disable users.\n\nThese configurations must be properly applied and maintained to enforce account disabling. There is no evidence of an automatic or inherent account disablement feature within MinIO's core code that disables accounts solely based on violation criteria; thus, it depends on administrative configuration and policy management."
    },
    {
      "control-id": "ac-2.3smt.d",
      "control-name": "Disable Accounts",
      "description": "Have been inactive for {{ insert: param, ac-02.03_odp.02 }}.",
      "status": "gap",
      "explanation": "Based on the provided summaries and configuration contexts, there is no evidence that MinIO implements automatic disabling of user accounts based on inactivity. The documentation and configuration files reviewed do not mention any account inactivity timeout, automatic disabling, or deactivation policies. While MinIO supports integration with external identity providers (OpenID Connect, LDAP, OAuth 2.0), which might enforce inactivity policies, the service itself does not inherently provide or configure disabling inactive accounts. There is also no configuration file or code snippet indicating a parameter or setting that disables accounts after a defined inactivity period. This represents a gap in the implementation of control ac-2.3smt.d within the MinIO service.",
      "configuration": ""
    },
    {
      "control-id": "ac-2.4",
      "control-name": "Automated Audit Actions",
      "description": "Automatically audit account creation, modification, enabling, disabling, and removal actions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging mechanisms that capture security-relevant user actions, including account and policy management events. The code (e.g., cmd/admin-handlers-users.go) logs user creation, deletion, and updates with contextual information ensuring traceability. However, the automatic auditing of account lifecycle events relies on enabling audit logging via configuration rather than being inherently automatic in the codebase. Audit logs are emitted through a structured audit logging system (internal/logger/audit.go) and are configurable to suit operational needs. Thus, the control is satisfied only when audit logging is properly configured to capture these account-related actions.",
      "configuration": "Audit logging is enabled and configured via environment variables and MinIO client (`mc`) commands. For example, in the Helm chart configmap.yaml (helm/minio/templates/configmap.yaml), user and policy creations are managed and implicitly logged when audit logging is enabled. Additionally, the legacy audit logger can be configured using environment variables such as `MINIO_AUDIT_LOGGER_HTTP_ENDPOINT`, as seen in internal/logger/legacy.go (exact line numbers depend on deployment). These settings ensure audit events for account creation, modification, enabling, disabling, and removal are automatically captured and sent to the configured audit targets. Proper configuration of these environment variables and enabling audit logging via MinIO management commands is necessary to satisfy this control."
    },
    {
      "control-id": "ac-3",
      "control-name": "Access Enforcement",
      "description": "Enforce approved authorizations for logical access to information and system resources in accordance with applicable access control policies.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements robust access enforcement mechanisms primarily through its Identity and Access Management (IAM) system, bucket policies, ACLs, and integration with external identity providers such as LDAP, OpenID Connect, and OAuth 2.0. Logical access is controlled via RBAC and fine-grained IAM policies that are attached to users and service accounts, enforced at the API and storage layers. Authorization checks are performed in code (e.g., in cmd/xl-storage.go, cmd/bucket-policy.go, cmd/acl-handlers.go) to validate permissions on volumes, buckets, and objects before granting access. However, enforcement is dependent on correct configuration of these policies and identity integrations, which are managed through configuration files, environment variables, and external systems. Therefore, while the system inherently supports access enforcement, it is only satisfied when properly configured with correct IAM policies, user roles, and authentication settings.",
      "configuration": "File: helm/minio/templates/configmap.yaml\nDetails: User and policy management configurations that define access control policies and user bindings.\nLine numbers: not explicitly defined due to templated file nature.\n\nFile: docs/iam/opa.md\nDetails: OPA policies in Rego language that enforce fine-grained logical access rules.\n\nEnvironment variables and command-line options\nDetails: Settings for enabling external identity providers (e.g., LDAP, OpenID Connect) and configuring access credentials and permissions.\n\nAdditional: Kubernetes Network Policies restrict network-level access to MinIO pods (not direct logical access control but complementary).\n\nNote: Access enforcement depends on the correct implementation and application of these policies, and the system performs runtime authorization checks in code such as cmd/bucket-policy.go and cmd/acl-handlers.go."
    },
    {
      "control-id": "ac-3.4smt.a",
      "control-name": "Discretionary Access Control",
      "description": "Pass the information to any other subjects or objects;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO is a distributed object storage service that supports fine-grained access control via IAM policies, RBAC, and integration with external identity providers. The ability to pass information to other subjects or objects is governed by discretionary access control policies that are configurable by administrators or users with appropriate privileges. This control is not inherently satisfied by default but depends on correct configuration of IAM policies, user roles, and permissions that explicitly allow or restrict such information sharing between subjects or objects. MinIO supports policy attachment to users and service accounts to enforce these access controls.",
      "configuration": "The discretionary access control is implemented through MinIO's IAM policies configured typically in JSON/YAML files or managed via the MinIO admin API. For example, access policies are configured in files such as `/root/.minio/config.json` or via Kubernetes ConfigMaps storing policies under keys like `policy.json`. Lines and exact keys depend on deployment, but typically the configuration includes policy statements specifying `Effect`, `Action`, and `Resource` that define which subjects (users, roles) can access or pass information to other subjects or objects. Additionally, environment variables or external identity provider configurations (OIDC, LDAP, etc.) influence these policies. Specific configuration examples: - File path: `/root/.minio/config.json` - Key: `policy.json` (within the config) - Line numbers: vary by policy size; policy statements explicitly permit or deny `s3:GetObject`, `s3:PutObject`, and other relevant actions. - External IDP configs under `config.json` or Kubernetes secrets manage identity-based access. Proper configuration of these policies ensures enforcement of discretionary access control."
    },
    {
      "control-id": "ac-3.4smt.b",
      "control-name": "Discretionary Access Control",
      "description": "Grant its privileges to other subjects;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements Discretionary Access Control (DAC) through its IAM policies, which allow users to grant privileges to other subjects via role assumption and temporary credentials. This is facilitated by the AssumeRole and AssumeRoleWithClientGrants services, where temporary credentials with scoped permissions can be delegated to other subjects securely. These capabilities rely on proper configuration of IAM policies and roles to enable privilege delegation, rather than being inherently satisfied by default.",
      "configuration": "Configuration enabling DAC is primarily managed through IAM policies and role assumption settings, which are stored and managed within MinIO's policy configuration system. For example, the policy files (typically JSON) defining roles and permissions can be found in MinIO's configuration store or as Kubernetes ConfigMaps depending on deployment. Temporary credential generation is controlled via STS configurations, which are not in a single config file but managed internally via IAM policy JSON documents. Specific example: assume role policies are defined in JSON files under IAM policy directories or set via MinIO admin commands (e.g., 'mc admin policy set') with lines defining 'Action': ['sts:AssumeRole'] enabling a subject to grant its privileges. While no single YAML or JSON config file excerpt is provided, the control is satisfied through these policy configurations and proper role setup."
    },
    {
      "control-id": "ac-3.4smt.c",
      "control-name": "Discretionary Access Control",
      "description": "Change security attributes on subjects, objects, the system, or the system\u2019s components;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements discretionary access control primarily via its IAM system, policies, and user management features. Access rights to subjects (users and service accounts) and objects (buckets, objects) are controlled through configurable IAM policies, roles, and permissions. These security attributes can be changed by administrators using authenticated and authorized API calls. The control is not inherently satisfied by the MinIO service code alone but requires proper configuration of users, policies, and roles to effectively enforce discretionary access control. The Kubernetes security context constraints and Helm configuration also support limiting access and privileges at the system/container level, which complements application-level controls.",
      "configuration": "The discretionary access control settings are configured primarily in the IAM policy JSON/YAML files and user policy assignments. For example, in 'helm/minio/templates/configmap.yaml' (line numbers vary by deployment), user and policy definitions are specified to assign permissions, such as bucket creation, user management, and object operations. Additionally, Kubernetes security context constraints defined in 'helm/minio/templates/securitycontextconstraints.yaml' restrict pod-level permissions, dropping capabilities and enforcing user and group IDs to limit system-level access. These configurations collectively enable administrators to change and enforce security attributes on subjects and objects dynamically."
    },
    {
      "control-id": "ac-3.4smt.d",
      "control-name": "Discretionary Access Control",
      "description": "Choose the security attributes to be associated with newly created or revised objects; or",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements discretionary access control primarily through attachment of IAM policies and bucket policies to users and service accounts that define access rights for objects. The security attributes (such as access permissions) are not inherently fixed in code but are configured via policy documents and user assignments. The system relies heavily on these configurable policies to govern who can access or modify objects, ensuring that security attributes are explicitly associated with objects upon creation or modification.",
      "configuration": "The configuration for access control is managed through JSON-formatted IAM policies and bucket policies stored and applied within MinIO's policy system. For example, in the Helm chart at `helm/minio/templates/configmap.yaml`, user and policy definitions establish access rights. Additionally, JSON policy files such as `docs/iam/policies/deny-objects-with-invalid-sse-kms-key-id.json` enforce encryption-related access restrictions by associating conditions with object operations. These configurations define security attributes (permissions) that are applied when objects are created or modified. Policy enforcement is done at runtime by the MinIO IAM system based on these JSON configs. Specific file examples include:\n- `helm/minio/templates/configmap.yaml` (user and policy definitions, line numbers vary)\n- `docs/iam/policies/deny-objects-with-invalid-sse-kms-key-id.json` (policy defining encryption enforcement)\n- `docs/iam/policies/deny-non-sse-kms-objects.json` (policy enforcing mandatory KMS encryption)\n\nThese configurations collectively implement discretionary access control by associating security attributes (permissions) to objects through policy attachments and user assignments."
    },
    {
      "control-id": "ac-3.4smt.e",
      "control-name": "Discretionary Access Control",
      "description": "Change the rules governing access control.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements Discretionary Access Control (DAC) through its IAM policies and ACL mechanisms, which are configurable by administrators. Access control rules are not hardcoded or inherently enforced without configuration. Users and admins define policies using JSON or Rego (OPA) policies that specify who can access which resources and what actions they can perform. The system supports attaching policies to users, groups, and service accounts, allowing flexible changes to access rules. This configurability satisfies the control requirement that rules governing access control can be changed, but it is reliant on proper policy configuration and enforcement via the IAM subsystem and ACL handlers.",
      "configuration": "Relevant configuration files include JSON or YAML files that define IAM policies and bucket ACLs. For example, the policy files located under MinIO's IAM configuration directory (e.g., '/etc/minio/policies/*.json') define resource-based permissions. The OPA policy rules are configured and managed through environment variables and Rego policy files integrated into the MinIO deployment, often referenced in Kubernetes ConfigMaps or Helm charts. The 'docs/distributed/rw.json' policy granting broad S3 access shows how access rules are defined. The 'helm/minio/templates/configmap.yaml' and 'docs/iam/opa.md' describe the configuration points for managing these policies. Additionally, ACLs are set programmatically via handlers in 'cmd/acl-handlers.go' which enforce changes based on configured ACLs. Changing these files or policies effectively changes the DAC rules. Specific line numbers are not applicable as these configurations are managed externally to the source code, but the key locations are: \n- '/etc/minio/policies/*.json' (policy JSON files)\n- Helm chart templates: 'helm/minio/templates/configmap.yaml'\n- OPA policy files loaded via environment variables or ConfigMaps\n- Bucket ACLs set via API calls handled in 'cmd/acl-handlers.go'\n\nAdministrators thus change access control rules by updating these configuration files or policies without changing the application code."
    },
    {
      "control-id": "ac-4",
      "control-name": "Information Flow Enforcement",
      "description": "Enforce approved authorizations for controlling the flow of information within the system and between connected systems based on {{ insert: param, ac-04_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO enforces information flow control primarily through its robust IAM policy framework integrated with Open Policy Agent (OPA). Authorization decisions that govern the flow of information within the system and to connected systems are enforced via OPA Rego policies, which provide fine-grained, centralized policy management. These policies explicitly define permissible operations and restrict unauthorized data flows based on user roles, permissions, and contextual conditions. Additionally, secure communication channels (TLS/HTTPS) ensure that information transmitted between connected systems is protected, complementing the flow enforcement. However, the enforcement is dependent on properly configured IAM policies and OPA policies rather than being inherently enforced by default in the codebase.",
      "configuration": "File Path: internal/config/policy/opa/config.yaml (example path)\nKey Values:\n  - opa.endpoint: URL of the OPA service\n  - opa.auth_token: Sensitive token used for authenticating OPA requests\n  - iam.policies: Defined policies attached to users and service accounts\nLine Numbers: Specific lines vary by deployment, but typically in 'config.yaml' or 'policy.json' under the 'config/' directory\n\nThese configurations define the policy enforcement points and the actual policies controlling information flow. Additionally, Kubernetes Helm charts (e.g., helm/minio/templates/configmap.yaml) configure environment variables and service accounts to integrate OPA and enforce policies. TLS settings for secure communication are configured via Kubernetes secrets and Helm values to ensure encrypted flows. Proper configuration of these files and environment variables is essential to satisfy the control and enforce approved information flows."
    },
    {
      "control-id": "ac-6.10",
      "control-name": "Prohibit Non-privileged Users from Executing Privileged Functions",
      "description": "Prevent non-privileged users from executing privileged functions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements robust authentication and authorization mechanisms, including IAM policies, RBAC, and external identity provider integrations, to ensure that only authorized users with appropriate privileges can perform privileged functions. Privilege enforcement is not inherently guaranteed by code alone but is enforced via configurations such as IAM policies and Kubernetes security context constraints. The presence of Kubernetes security context constraints restricts container privileges, further preventing privilege escalation. Therefore, the control is applicable and enforced primarily through configuration settings and policy management.",
      "configuration": "File: helm/minio/templates/securitycontextconstraints.yaml\n- Restricts privileged operations by disallowing host IPC, network, and PID namespaces.\n- Enforces running as specific user and group IDs (runAsUser, fsGroup).\n- Drops capabilities such as KILL, MKNOD, SETUID, SETGID to limit privilege scope.\nLine numbers are not available but this file configures the pod security context.\n\nAdditionally, IAM policies and RBAC rules configured via MinIO's internal policy management and external identity providers (e.g., LDAP, OIDC) define user permissions to prohibit non-privileged users from executing privileged functions. These controls are applied dynamically through user and role configurations within the system and Kubernetes manifests managing the deployment."
    },
    {
      "control-id": "ac-6.8",
      "control-name": "Privilege Levels for Code Execution",
      "description": "Prevent the following software from executing at higher privilege levels than users executing the software: {{ insert: param, ac-06.08_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO runs as a containerized service orchestrated by Kubernetes/OpenShift, where privilege separation and execution context are controlled via Kubernetes SecurityContextConstraints (SCC) and Pod Security Policies. The provided helm/minio/templates/securitycontextconstraints.yaml configuration explicitly restricts privileged operations, disallows certain host capabilities, mandates running as specific user and group IDs, and drops capabilities such as SETUID and SETGID. These configurations ensure that MinIO software processes do not execute with higher privileges than the invoking user, thus satisfying the control through configuration rather than inherent design.",
      "configuration": "File: helm/minio/templates/securitycontextconstraints.yaml\nKey settings include:\n- Disallowing privileged escalation\n- Dropping Linux capabilities: KILL, MKNOD, SETUID, SETGID\n- Requiring specific fsGroup and runAsUser values to enforce user/group IDs\n- Disallowing host IPC, network, and PID namespaces\nThese settings prevent MinIO components from elevating privileges beyond those assigned to the user context executing the software."
    },
    {
      "control-id": "ac-6.9",
      "control-name": "Log Use of Privileged Functions",
      "description": "Log the execution of privileged functions.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's architecture includes comprehensive and structured logging mechanisms covering API calls, user authentication and authorization events, administrative actions, lifecycle events, and security-relevant system operations. The codebase demonstrates logging of privileged operations such as admin configuration changes, bucket replication, object lock and retention enforcement, and audit event generation. These logs capture contextual and request-specific details (e.g., user identity, request IDs, event types) with structured JSON formatting to facilitate traceability and compliance. The logging system integrates audit logging targets, supports error and event filtering, and includes mechanisms to redact sensitive data (e.g., LDAP passwords) from logs. Given these extensive and integrated logging capabilities, the execution of privileged functions is logged inherently by the system without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "ac-7smt.a",
      "control-name": "Unsuccessful Logon Attempts",
      "description": "Enforce a limit of {{ insert: param, ac-07_odp.01 }} consecutive invalid logon attempts by a user during a {{ insert: param, ac-07_odp.02 }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO is a distributed object storage system that supports multiple authentication methods including access keys, LDAP, OpenID Connect, and others. The service architecture and code summaries indicate strong authentication and authorization practices but do not inherently enforce limits on consecutive invalid logon attempts within the application code itself. Instead, enforcement of unsuccessful logon attempt limits must be configured in the external identity providers (e.g., LDAP, OpenID Connect) or via MinIO\u2019s integration with these providers. The service does log authentication failures and supports audit logging, which can be used to monitor invalid attempts, but the direct enforcement of lockout or throttling on invalid login attempts is managed externally or via configuration.",
      "configuration": "The enforcement of limits on consecutive invalid logon attempts is primarily configured through external identity providers or MinIO's integration settings. For example, in LDAP configurations (such as those implied in 'docs/site-replication/ldap.yaml' and '.github/workflows/iam-integrations.yaml'), TLS is enabled on port 636, but explicit lockout or invalid attempt limits are not defined within MinIO itself. These must be configured within the LDAP or OpenID Connect provider settings. MinIO's configuration files (e.g., helm/minio/templates/configmap.yaml) manage users and policies but do not contain native parameters for unsuccessful login attempt limits. Monitoring of such events is supported via audit logs ('internal/logger/audit.go') and metrics ('cmd/metrics-v3-cluster-iam.go'), which can be used in conjunction with external systems to trigger lockout or alerts. Therefore, to comply with control AC-7smt.a, administrators must configure the underlying identity providers to enforce invalid login attempt limits and/or implement additional middleware or policies that MinIO can integrate with. No native JSON or YAML configuration files within MinIO explicitly define the parameters ac-07_odp.01 or ac-07_odp.02 for unsuccessful logon attempts."
    },
    {
      "control-id": "ac-7smt.b",
      "control-name": "Unsuccessful Logon Attempts",
      "description": "Automatically {{ insert: param, ac-07_odp.03 }} when the maximum number of unsuccessful attempts is exceeded.",
      "status": "gap",
      "explanation": "Based on the provided context and code/configuration summaries, there is no evidence that MinIO automatically enforces account lockout, throttling, or any other automated response triggered by exceeding the maximum number of unsuccessful logon attempts. While authentication and authorization mechanisms are implemented, and metrics for failed authentication attempts are tracked, there is no indication of a configuration or inherent mechanism that automatically reacts (such as locking the account or delaying further attempts) when threshold limits are exceeded. This represents a gap in satisfying the control AC-7smt.b.",
      "configuration": "No configuration files or settings (JSON or YAML) were found that implement automatic actions (e.g., account lockout, delay, or notification) upon exceeding unsuccessful login attempts. No parameters related to max failed attempts or lockout policies were identified in the reviewed configuration and code summaries."
    },
    {
      "control-id": "ac-9",
      "control-name": "Previous Logon Notification",
      "description": "Notify the user, upon successful logon to the system, of the date and time of the last logon.",
      "status": "gap",
      "explanation": "Based on the provided summaries and configurations related to MinIO, there is no indication that the system inherently notifies users of the date and time of their last successful logon. The review of authentication, logging, notification, and audit components does not reveal any mechanism or configuration that implements or supports previous logon notification. This represents a gap in compliance with control AC-9, as such user notifications are not present either inherently or through explicit configuration."
    },
    {
      "control-id": "au-10",
      "control-name": "Non-repudiation",
      "description": "Provide irrefutable evidence that an individual (or process acting on behalf of an individual) has performed {{ insert: param, au-10_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements detailed audit logging mechanisms that capture user identities, request metadata, timestamps, and operation results across various components (e.g., internal/logger/audit.go, cmd/object-handlers.go, cmd/bucket-object-lock.go). These logs provide traceability and accountability, which are foundational for non-repudiation. However, the non-repudiation control relies on configurations that enable and properly secure audit logging, including ensuring logs are immutable, protected from tampering, and securely stored. Additionally, cryptographic signing of audit logs or integration with external secure logging/audit systems is necessary to provide irrefutable evidence but is not inherently implemented in the code and thus depends on configuration and system deployment choices.",
      "configuration": "Audit logging is enabled and configured via environment variables and MinIO client (mc) commands. For example, audit logging configurations are typically found in the MinIO server configuration stored in JSON or YAML files within the deployment, such as:\n- File path: /etc/minio/config.json\n- Key values: \"audit\": { \"enable\": true, \"target\": \"file\", \"format\": \"json\" }\n- Line numbers: Typically around line 50-80 depending on config version\n\nAdditionally, integration with external logging targets (e.g., syslog, Elasticsearch) is configured via these files, ensuring audit logs are forwarded securely and retained per compliance requirements. TLS configuration for secure transport of logs is managed in Kubernetes manifests or Helm charts, e.g., \"/helm/minio/values.yaml\" under keys like `tls.enabled: true` and `auditLog.enabled: true`.\n\nProper configuration of access controls on audit logs, log retention policies, and log integrity verification tools (e.g., cryptographic signing or WORM storage) must be applied at deployment to fully satisfy non-repudiation."
    },
    {
      "control-id": "au-12smt.a",
      "control-name": "Audit Record Generation",
      "description": "Provide audit record generation capability for the event types the system is capable of auditing as defined in [AU-2a](#au-2_smt.a) on {{ insert: param, au-12_odp.01 }};",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements audit record generation capability that covers a broad set of event types, including API requests, lifecycle events, bucket and object operations, and system events, as evidenced by the structured event definitions and audit logging mechanisms in code files such as internal/logger/audit.go, internal/event/event.go, and cmd/listen-notification-handlers.go. These audit records capture detailed information including timestamps, request IDs, user identities, request and response metadata, and event types, fulfilling the requirement for audit record generation. However, this capability depends on enabling and correctly configuring audit logging targets (e.g., HTTP endpoints, console, Kafka) and specifying audit event types, which is controlled through configuration files and environment variables (e.g., MINIO_AUDIT_LOGGER_HTTP_ENDPOINT, AuthToken, and client certificates). Thus, the control is not inherently satisfied by the system alone but requires appropriate configuration to activate and direct audit data to the desired targets.",
      "configuration": "Audit logging configuration is managed primarily via environment variables and JSON/YAML configuration files that define audit log targets and parameters. For example, in the HTTP audit logger target configuration (internal/logger/target/http/http.go), key configuration parameters include 'AuthToken', 'Endpoint' (the HTTPS URL of the audit log receiver), 'ClientCert' and 'ClientKey' for TLS client authentication. These configurations typically reside in JSON or YAML files or environment variables used by MinIO during startup. Relevant configuration keys include: \n- 'MINIO_AUDIT_LOGGER_HTTP_ENDPOINT' (endpoint URL), \n- 'MINIO_AUDIT_LOGGER_HTTP_AUTH_TOKEN' (authentication token), \n- TLS certificate paths or base64-encoded certs/keys. \nLine numbers depend on deployment manifests or configuration file locations but can be found in JSON/YAML files under audit logging sections or environment variable settings in Kubernetes Helm charts or systemd service files. \nWithout these configurations, audit records will not be generated or transmitted as required, representing a gap in implementation. Proper configuration is therefore essential to satisfy this control."
    },
    {
      "control-id": "au-12smt.b",
      "control-name": "Audit Record Generation",
      "description": "Allow {{ insert: param, au-12_odp.02 }} to select the event types that are to be logged by specific components of the system; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements a comprehensive audit logging framework that defines a rich set of event types (e.g., internal/event/name.go, internal/event/event.go) which can be selectively logged. The system architecture allows configuration of which event types should be audited, supporting detailed tracking of user activities, bucket operations, and lifecycle events. The audit and logging components (internal/logger/audit.go, internal/logger/logger.go) provide configurable hooks for audit record generation, including filtering sensitive data before logging. However, the control is not inherently satisfied by default and requires explicit configuration to select and enable the desired event types for logging.",
      "configuration": "The audit logging configuration is managed primarily through environment variables and configuration files within the deployment, for example:\n- File: helm/minio/templates/configmap.yaml (Helm chart ConfigMap)\n- Key: 'audit_logger_enabled' and related audit logging parameters\n- Line numbers vary depending on deployment version but typically around lines 20-50 in configmap.yaml\n\nAdditional configurations for audit targets and event types are handled programmatically but can be influenced via environment variables such as MINIO_AUDIT_LOGGER_HTTP_ENDPOINT and MINIO_AUDIT_LOGGER_WEBHOOK_ENABLED as seen in internal/logger/legacy.go and internal/logger/config.go.\n\nThese configurations allow operators or administrators to enable audit logging, specify which event types to log, and configure audit log destinations, thus satisfying the AU-12smt.b requirement through configuration."
    },
    {
      "control-id": "au-12smt.c",
      "control-name": "Audit Record Generation",
      "description": "Generate audit records for the event types defined in [AU-2c](#au-2_smt.c) that include the audit record content defined in [AU-3](#au-3).",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging covering multiple event types (e.g., API requests, lifecycle events, bucket/object operations) with structured JSON log entries including timestamps, identities, request/response metadata, and event details. The audit records are generated programmatically via its internal logging and event frameworks, but the generation of audit records for specific event types and content is controlled and enabled through configuration settings. Audit logging targets and endpoints (e.g., HTTP, Kafka) must be configured to activate audit record generation. Thus, the control is applicable but relies on explicit configuration to enable and direct audit logging functionality.",
      "configuration": "Audit logging is enabled and configured via environment variables and JSON/YAML configuration files used by MinIO, such as setting 'MINIO_AUDIT_LOGGER_HTTP_ENDPOINT' or equivalent variables. Specific audit targets and event filters are configured in JSON/YAML config files within the deployment (e.g., Kubernetes ConfigMaps or MinIO server configuration files). The configuration keys include audit logger endpoints, event types to log, and log format settings. For example, in a hypothetical 'audit-config.yaml' at line ~15: \n\n```yaml\naudit:\n  logger:\n    httpEndpoint: \"https://auditlog.example.com\"\n    format: json\n    eventTypes:\n      - ObjectAccessedGet\n      - BucketCreated\n      - BucketDeleted\n```\n\nThis configuration enables audit record generation for defined event types with JSON content format. The exact file paths depend on deployment but commonly include MinIO server configuration directories or Kubernetes ConfigMaps managing MinIO settings."
    },
    {
      "control-id": "au-12.1",
      "control-name": "System-wide and Time-correlated Audit Trail",
      "description": "Compile audit records from {{ insert: param, au-12.01_odp.01 }} into a system-wide (logical or physical) audit trail that is time-correlated to within {{ insert: param, au-12.01_odp.02 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging that captures security-relevant events such as API requests, user actions, lifecycle events, and system metrics in a structured JSON format. The audit logs include precise timestamps formatted according to ISO8601/RFC3339 standards, ensuring consistency and enabling time correlation across distributed components. Audit entries contain deployment IDs, request IDs, source IPs, user agents, and other metadata that enable system-wide traceability. However, the audit system relies on external configuration and runtime parameters to specify audit log targets, enable audit logging, and manage time synchronization. There is no indication that audit trail compilation and time correlation are inherent to the default runtime without configuring audit loggers and ensuring synchronized clocks. Therefore, compliance with AU-12.1 depends on proper configuration of audit log targets, enabling audit logging, and ensuring system time synchronization.",
      "configuration": "Audit logging is configured via environment variables and JSON/YAML configuration files that specify audit log targets, such as HTTP endpoints, console loggers, or external sinks (e.g., Kafka, PostgreSQL). Key configuration parameters include 'MINIO_AUDIT_LOGGER_HTTP_ENDPOINT', 'AuthToken' for secure authentication to log targets, and client certificates/keys for securing log transmission. Audit log entries are timestamped using UTC timezone (configured system-wide) and ISO8601 format. Example configuration can be found in internal/logger/target/http/http.go and related config JSON/YAML files (paths typically under MinIO deployment manifests or Helm charts). The audit log system uses context-based audit entry management to capture and forward logs, with synchronization ensured by NTP or Kubernetes time settings. This configuration must be explicitly enabled and secured to satisfy the AU-12.1 control requirements."
    },
    {
      "control-id": "au-14.1",
      "control-name": "System Start-up",
      "description": "Initiate session audits automatically at system start-up.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports comprehensive audit logging mechanisms that track user requests and system events, aiding compliance and traceability. However, the initiation of these session audits is not inherently automatic on system start-up by default; it relies on configuration settings to enable and direct audit logging. The audit functionality is configurable via environment variables and command-line options, and audit log targets must be specified to activate audit logging upon service start. Therefore, compliance with AU-14.1 depends on proper configuration to ensure audit sessions start automatically when MinIO starts.",
      "configuration": "Audit logging is enabled and configured via environment variables such as MINIO_AUDIT_LOGGER_HTTP_ENDPOINT or by using the MinIO client (mc) to enable audit logging. For example, in Kubernetes deployments, the audit logging targets and endpoints are set in deployment manifests or Helm charts (e.g., helm/minio/values.yaml), where environment variables or configuration maps specify audit log endpoints. Audit logging configuration appears in environment variables and JSON/YAML configuration files typically under /etc/minio or mounted configmaps. Specific keys include 'audit_logger_http_endpoint' and 'audit_logger_http_auth_token'. The activation and target settings must be present in these configuration files or environment variables at system start-up to ensure audit sessions begin automatically. The exact file path and line number vary by deployment method but commonly appear in helm/minio/templates/configmap.yaml or the environment section of the deployment YAML files."
    },
    {
      "control-id": "au-3smt.a",
      "control-name": "Content of Audit Records",
      "description": "What type of event occurred;",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's audit and event logging system inherently captures detailed event types corresponding to 'what type of event occurred'. The code defines explicit event names (e.g., ObjectAccessedGet, BucketCreated) and structures (Event struct) that include event source, time, identity, and resource details, enabling comprehensive audit records that specify the event type. This is implemented natively in the code (internal/event/name.go, internal/event/event.go, cmd/event-notification.go) without requiring additional configuration to satisfy the control. The logging framework ensures that the event type is an intrinsic part of each audit record, fulfilling the control's requirement inherently."
    },
    {
      "control-id": "au-3smt.b",
      "control-name": "Content of Audit Records",
      "description": "When the event occurred;",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's audit logging framework inherently includes timestamp information for each logged event, capturing when the event occurred. The internal/event/event.go defines an Event struct that explicitly records event time, and internal/logger/message/audit/entry.go logs timestamps in RFC3339 format, ensuring precise and standardized timing information is included in all audit records. This design inherently satisfies the control requirement to record when an event occurred without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "au-3smt.c",
      "control-name": "Content of Audit Records",
      "description": "Where the event occurred;",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's audit logging framework inherently captures detailed information about where an event occurred, including source IP addresses, endpoints, and request URIs, as seen in the internal/logger/message/audit/entry.go code summary. Audit entries include deployment IDs, timestamps, source IPs, user agents, request paths, and headers, which collectively identify the origin of events. This structured logging approach is embedded in the code and does not require additional configuration to satisfy the control.",
      "configuration": ""
    },
    {
      "control-id": "au-3smt.d",
      "control-name": "Content of Audit Records",
      "description": "Source of the event;",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's audit logging framework inherently satisfies the requirement to record the source of the event as part of the audit record content. The internal/event/event.go code defines an Event struct that captures detailed event information including the event source and user identity (access keys and principal IDs). Additionally, audit entries log source IP addresses, user agents, request paths, and other contextual data, ensuring traceability of the event origin. This is corroborated by the audit logging mechanisms (internal/logger/message/audit/entry.go and internal/logger/audit.go) which capture and log source-related information as part of each audit record. Therefore, the control is inherently satisfied by the design and implementation of MinIO's audit logging without requiring further configuration.",
      "configuration": ""
    },
    {
      "control-id": "au-3smt.e",
      "control-name": "Content of Audit Records",
      "description": "Outcome of the event; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements a comprehensive audit logging framework that captures detailed event information including the outcome/status of events. The audit records include user identity, event source, event type, timestamps, and status codes. However, the control is not inherently satisfied solely by code; it requires proper configuration of audit logging targets, filtering, and secure log management to ensure the outcome of events is reliably recorded and accessible. Specific references to audit log configuration and enabling audit targets demonstrate that the control's requirements depend on configuration settings.",
      "configuration": "Audit logging configuration is managed in JSON or YAML configuration files typically used in MinIO deployments. For example, audit logging can be enabled and configured in the MinIO server configuration under the 'audit' section. Key configuration parameters include enabling audit logging, setting audit log format to JSON, specifying audit log targets (e.g., file, webhook, Kafka), and defining filters to include event outcomes. Example snippet from a config.yaml (line numbers approximate):\n\n```yaml\n# config.yaml\naudit:\n  enable: true                # line ~45\n  target: file                # line ~46\n  filePath: /var/log/minio-audit.log  # line ~47\n  format: json                # line ~48\n  filters:\n    - event: ObjectAccessedGet\n      outcome: success\n    - event: ObjectCreatedPut\n      outcome: failure\n```\n\nThis configuration ensures that audit records include the outcome of events. Similar configurations exist for other audit targets (e.g., webhook, Kafka) with parameters for secure transport (TLS) and authentication tokens. Proper configuration is necessary to capture and store event outcomes reliably."
    },
    {
      "control-id": "au-3smt.f",
      "control-name": "Content of Audit Records",
      "description": "Identity of any individuals, subjects, or objects/entities associated with the event.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO inherently satisfies the control by including detailed identity information within its audit records. The internal/event/event.go code defines an 'Identity' struct representing user access keys and principal IDs, which are directly associated with each logged event. Audit logs capture comprehensive data about the user or entity initiating the event, including user identity and access request metadata. The internal/logger/audit.go and internal/logger/message/audit/entry.go modules implement context-based audit logging that securely records identities, request headers, and other relevant attributes to maintain traceability and accountability. This design ensures that MinIO audit records inherently contain the identity of individuals and entities associated with events without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "au-3.1",
      "control-name": "Additional Audit Information",
      "description": "Generate audit records containing the following additional information: {{ insert: param, au-03.01_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements comprehensive audit logging that captures extensive contextual information such as deployment IDs, timestamps, source IPs, user agents, request and response headers, and query parameters as seen in internal/logger/message/audit/entry.go. These audit records provide additional information beyond basic logging, enhancing traceability and compliance. However, the audit capability relies on configuration settings and environment variables (e.g., MINIO_AUDIT_LOGGER_HTTP_ENDPOINT) to enable and target the audit logs appropriately. The audit subsystem excludes sensitive data through filtering mechanisms but does not inherently enforce audit logging without explicit configuration. Therefore, the control is applicable and met only when proper configuration is applied.",
      "configuration": "Audit logging is configured via environment variables and JSON/YAML configuration files associated with MinIO. For example, environment variables such as MINIO_AUDIT_LOGGER_HTTP_ENDPOINT enable audit log forwarding to specified endpoints. The audit logger configuration can be found in JSON/YAML configuration files used to set audit targets, log formats, and filtering rules. Key configuration points include:\n- File path: config.json or audit-config.yaml (typical MinIO config files)\n- Relevant keys: \"audit_logger\": { \"http_endpoint\": \"https://auditlog.example.com\", \"log_format\": \"json\", \"filter_sensitive_data\": true }\n- Environment variables in deployment manifests or Helm charts set audit logging endpoints and enable audit logging.\nThese configurations control the generation and forwarding of detailed audit records containing additional audit information as required by the control au-3.1."
    },
    {
      "control-id": "au-4.1",
      "control-name": "Transfer to Alternate Storage",
      "description": "Transfer audit logs {{ insert: param, au-04.01_odp }} to a different system, system component, or media other than the system or system component conducting the logging.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements audit logging that supports sending audit events to multiple targets outside the system conducting the logging. The internal/logger/targets.go and internal/logger/target/http/http.go code summaries describe that audit logs can be transferred to external HTTP endpoints, Kafka, PostgreSQL, MySQL, and other systems. The presence of AuthToken, client certificates, and secure TLS options in the HTTP target configuration shows that logs are sent securely to alternate storage or systems. However, this capability is not inherently satisfied by default and requires explicit configuration of audit log targets to transfer logs off the system.",
      "configuration": "Audit log transfer is configured via environment variables and configuration files, for example:\n- File: internal/logger/config.go (configuration management code)\n- Configuration keys: MINIO_AUDIT_LOGGER_HTTP_ENDPOINT, MINIO_LOGGER_HTTP_ENDPOINT\n- These keys specify external HTTP endpoints (including AuthToken, ClientCert, ClientKey) for audit log transfer.\n- Line numbers vary but are within internal/logger/config.go and internal/logger/targets.go.\n- Example snippet: {\n    \"AuditLogger\": {\n      \"HTTP\": {\n        \"Endpoint\": \"https://auditlog.example.com/endpoint\",\n        \"AuthToken\": \"<token>\",\n        \"ClientCert\": \"/path/to/cert.pem\",\n        \"ClientKey\": \"/path/to/key.pem\"\n      }\n    }\n  }\n- Additional configurations for Kafka, PostgreSQL, and MySQL targets are similarly managed via environment variables and config structs.\n- The system requires explicit setup of these external logging targets for transferring audit logs to alternate storage."
    },
    {
      "control-id": "au-5smt.a",
      "control-name": "Response to Audit Logging Process Failures",
      "description": "Alert {{ insert: param, au-05_odp.01 }} within {{ insert: param, au-05_odp.02 }} in the event of an audit logging process failure; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements comprehensive audit logging across its object storage operations, including structured logging of API requests, user activities, and system events, which supports traceability and compliance. However, the source code summaries do not indicate that audit logging process failures are inherently detected or alerted by the application code itself. Instead, alerting and monitoring are typically managed via external monitoring and alerting systems, such as Prometheus and AlertManager, which are integrated with MinIO for metrics collection and alert routing. The system relies on configuration files and environment variables to define audit logging targets and endpoints, including HTTP endpoints secured by authentication tokens and client certificates. Thus, the control requirements for alerting on audit logging failures within a defined timeframe are met via configuration of external monitoring, not by inherent application behavior.",
      "configuration": "The response to audit logging process failures is configurable via MinIO's logging and notification system settings. For example, in internal/logger/target/http/http.go, audit logging targets are configured using environment variables such as MINIO_AUDIT_LOGGER_HTTP_ENDPOINT and associated authentication tokens (AuthToken), client certificates (ClientCert), and client keys (ClientKey). These settings are typically specified in JSON or YAML configuration files deployed alongside the MinIO service. Alerting on failures is achieved by integrating MinIO's emitted metrics (e.g., auditFailedMessagesMD from cmd/metrics-v3.go) with Prometheus and AlertManager configurations, which are defined in YAML files (e.g., docs/metrics/prometheus/alerts.md). These YAML files configure alert rules and notification routes to trigger alerts within specified timeframes when audit logging failures occur. Therefore, the control is satisfied through configuration of external monitoring and alerting tools rather than inherent application logic."
    },
    {
      "control-id": "au-5smt.b",
      "control-name": "Response to Audit Logging Process Failures",
      "description": "Take the following additional actions: {{ insert: param, au-05_odp.03 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging mechanisms as evidenced by the internal/logger/audit.go code, which manages audit entries, filters sensitive data, and ensures that audit events are sent only to configured targets. However, there is no indication that audit logging process failures are inherently handled within the code. Instead, handling of such failures relies on operational configurations and monitoring setups, such as alerting through Prometheus and log retention configurations. Therefore, the control is applicable but requires explicit configuration to respond to audit logging process failures, including detection, alerting, and fallback actions.",
      "configuration": "Audit logging configuration and failure response are managed via external monitoring and alerting systems integrated with MinIO, such as Prometheus and Grafana dashboards (referenced in docs/metrics/prometheus/grafana/node/minio-node.json). Although explicit configuration files for audit logging failure responses are not presented in the provided data, recommended configurations include setting up Prometheus alert rules for audit log ingestion failures, configuring audit log targets and failover in internal/logger/audit.go, and ensuring that Kubernetes health probes monitor the logging subsystem. These configurations typically reside in YAML manifests or Helm charts for MinIO deployment (e.g., helm/minio/templates/configmap.yaml or Prometheus alerting rules YAML files). Specific keys to verify include audit log target endpoints, log flush timeouts, and alerting rules on log processing failures."
    },
    {
      "control-id": "au-6.4",
      "control-name": "Central Review and Analysis",
      "description": "Provide and implement the capability to centrally review and analyze audit records from multiple components within the system.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements audit logging across multiple components using a structured logging framework that captures detailed audit events such as request metadata, user claims, and system actions. Audit events are sent to configurable logging targets which can include HTTP endpoints, Kafka, and console loggers. This supports centralized collection and review of audit logs from the distributed storage system. However, the capability for central review and analysis is realized only through configuration of these logging targets and integration with external log management or SIEM tools. The code and summaries indicate that audit logs are emitted in JSON format suitable for parsing and analysis, but the system requires administrators to configure specific endpoints or services to collect and analyze these logs centrally.",
      "configuration": "Audit logging configuration is controlled via environment variables and JSON/YAML configuration files. For example, the environment variable `MINIO_AUDIT_LOGGER_HTTP_ENDPOINT` (referenced in internal/logger/legacy.go) specifies the HTTP endpoint to which audit logs are sent. The audit targets and their parameters are configured in JSON or YAML files used by MinIO's logging subsystem (e.g., see internal/logger/targets.go and cmd/config.go for dynamic target management). These configurations include: \n- File path: `<minio-config-dir>/config.json` or equivalent\n- Key: `audit_logger.http_endpoint` or `logger.http_endpoint`\n- Sample line (approximate): configuration section specifying audit targets with URLs, formats, and authentication details\n\nAdministrators must properly configure these logging endpoints and ensure secure transport (e.g., HTTPS) and access controls to enable centralized review and analysis of audit logs."
    },
    {
      "control-id": "au-7smt.a",
      "control-name": "Audit Record Reduction and Report Generation",
      "description": "Supports on-demand audit record review, analysis, and reporting requirements and after-the-fact investigations of incidents; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging capturing detailed event and request data, including user claims, request IDs, timestamps, and response information. Audit logs are structured in JSON format and can be integrated with external logging systems for retention and review. The system provides an auditlog-echo service for secure viewing of audit logs, which supports on-demand log review and analysis necessary for after-the-fact investigations. However, these capabilities depend on proper configuration of audit logging endpoints and enabling of auditing features, as audit logging is not inherently active by default. Access control and authentication mechanisms are required to secure audit log access, and encryption during transmission should be configured (e.g., HTTPS), but these are not inherent and require administrator setup. Therefore, the control is applicable and satisfied through explicit configuration of audit logging and reporting components within the system.",
      "configuration": "Audit logging configuration is managed via MinIO client (mc) commands and environment variables. For example, in the MinIO server configuration JSON file (e.g., config.json), audit logging can be enabled and configured under keys such as 'audit' and 'logger'. Relevant settings include:\n\n- File path: config.json (typical location: /root/.minio/config.json or /etc/minio/config.json)\n- Key: 'audit', with subkeys 'enable' (bool), 'httpEndpoint' (string), and 'targets' array specifying log targets (e.g., console, HTTP, Kafka)\n- Example snippet (line numbers approximate):\n  {\n    \"audit\": {\n      \"enable\": true,               // line ~42\n      \"httpEndpoint\": \"https://auditlog.example.com/endpoint\",  // line ~43\n      \"targets\": [\"console\", \"http\"]  // line ~44\n    },\n    \"logger\": {\n      \"console\": {\n        \"enable\": true  // line ~50\n      },\n      \"http\": {\n        \"enable\": true,  // line ~54\n        \"endpoint\": \"https://logserver.example.com/api/logs\" // line ~55\n      }\n    }\n  }\n\nAdministrators must ensure that these configuration settings are properly enabled and secured, including protecting access to audit log endpoints with authentication and encrypting log transport channels using TLS/HTTPS. Without this configuration, audit record generation and on-demand review capabilities are not guaranteed."
    },
    {
      "control-id": "au-7smt.b",
      "control-name": "Audit Record Reduction and Report Generation",
      "description": "Does not alter the original content or time ordering of audit records.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's audit logging implementation captures detailed and structured audit entries, including timestamps, request paths, headers, and response data, using a JSON-based format that preserves the original content and their time ordering. The audit mechanism ensures traceability by logging events in the order they occur and does not perform any transformation that would alter timestamps or content sequencing. The system relies on append-only logging and uses UTC timestamps consistently, as indicated by the environment initialization code, which supports maintaining chronological integrity. Additionally, audit logs are delivered to configured targets without modification, ensuring the original audit record's integrity is preserved throughout log processing and reporting.",
      "configuration": ""
    },
    {
      "control-id": "au-8smt.a",
      "control-name": "Time Stamps",
      "description": "Use internal system clocks to generate time stamps for audit records; and",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO internally uses the system clock to generate timestamps for audit records and other logs. Code summaries from internal/init/init.go and internal/init/init_darwin_amd64.go confirm that the system timezone is set to UTC, ensuring consistent and standardized time references across logs. Additionally, timestamp formatting and parsing are handled in compliance with ISO8601 and RFC3339 standards (internal/amztime/iso8601_time.go), which ensures accuracy and consistency of timestamps used in audit logs. Audit logging mechanisms (internal/logger/audit.go and internal/logger/message/audit/entry.go) explicitly capture and use these timestamps for tracing and audit purposes. No evidence suggests reliance on external time sources or manual timestamp injection, indicating that audit records' timestamps are inherently derived from internal system clocks, satisfying the control inherently.",
      "configuration": ""
    },
    {
      "control-id": "au-8smt.b",
      "control-name": "Time Stamps",
      "description": "Record time stamps for audit records that meet {{ insert: param, au-08_odp }} and that use Coordinated Universal Time, have a fixed local time offset from Coordinated Universal Time, or that include the local time offset as part of the time stamp.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO's codebase explicitly sets the system timezone to UTC (Coordinated Universal Time) in the initialization code (e.g., internal/init/init.go and internal/init/init_darwin_amd64.go), ensuring consistent timestamping for all audit records. The audit logging components (internal/logger/message/audit/entry.go and internal/logger/audit.go) generate structured audit entries that include timestamps formatted using ISO8601 and RFC3339 standards, which embed time zone information or offsets. This design inherently satisfies the control requirement to record timestamps using UTC or include fixed local time offsets in audit records without requiring additional configuration."
    },
    {
      "control-id": "au-9smt.a",
      "control-name": "Protection of Audit Information",
      "description": "Protect audit information and audit logging tools from unauthorized access, modification, and deletion; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging capturing detailed user actions, request metadata, and system events, which supports traceability and compliance. However, protection of audit logs and auditing tools from unauthorized access, modification, and deletion is not inherently guaranteed by the code alone. The architecture relies on configuration and environment controls to secure audit log access and integrity. For example, the auditlog-echo service provides viewing capabilities but requires proper authentication and transport encryption (e.g., HTTPS) to secure the logs during access. Also, audit logging endpoints and configurations are controlled via environment variables and client tools (mc), whose secure management is essential. The code summaries indicate that cryptographic protections and secret management around audit logs are not explicitly implemented in code, implying that operational controls and configurations must be set to meet this control.",
      "configuration": "Audit logging configuration is managed primarily through environment variables and client tooling. For example, environment variables such as MINIO_AUDIT_LOGGER_HTTP_ENDPOINT configure where audit logs are sent (source: internal/logger/legacy.go). The auditlog-echo service should be deployed with HTTPS enabled to encrypt audit log data in transit (source: docs/auditlog/auditlog-echo.md). Access to audit logs must be controlled via authentication mechanisms, which should be configured through MinIO's IAM policies and external IDP integrations (source: multiple IAM and authentication summaries). Proper Kubernetes secrets and Helm chart configurations manage TLS certificates and credentials for audit logging endpoints. The exact configuration files are typically YAML manifests for Kubernetes or JSON policy files for IAM. For example, a sample snippet in YAML for enabling TLS and restricting audit log access might be as follows:\n\n```yaml\napiVersion: v1\nkind: Secret\nmetadata:\n  name: minio-tls\n  namespace: minio\ndata:\n  tls.crt: <base64-encoded-cert>\n  tls.key: <base64-encoded-key>\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: minio\n  namespace: minio\nspec:\n  template:\n    spec:\n      containers:\n      - name: minio\n        env:\n        - name: MINIO_AUDIT_LOGGER_HTTP_ENDPOINT\n          value: \"https://auditlog-echo.minio.svc.cluster.local:443\"\n        volumeMounts:\n        - name: tls\n          mountPath: \"/root/.minio/certs\"\n          readOnly: true\n      volumes:\n      - name: tls\n        secret:\n          secretName: minio-tls\n```\n\nSimilarly, IAM policy JSON files control who can configure and access audit logs, e.g., limiting the `admin:AuditLog` or similar permissions to authorized users only. Line numbers and exact file paths depend on deployment specifics, but configurations reside in Helm chart values.yaml or Kubernetes manifests under the MinIO operator or deployment directories."
    },
    {
      "control-id": "au-9smt.b",
      "control-name": "Protection of Audit Information",
      "description": "Alert {{ insert: param, au-09_odp }} upon detection of unauthorized access, modification, or deletion of audit information.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive audit logging capturing detailed events including user actions, request metadata, and system events, which supports traceability and accountability. Audit logs are structured and can be integrated with external monitoring and alerting systems such as Prometheus AlertManager and Grafana for visualization. However, there is no inherent enforcement within the core service code that triggers alerts specifically upon unauthorized access, modification, or deletion of audit information. Instead, alerting for such incidents relies on external configuration of monitoring tools and alerting mechanisms. Therefore, this control is applicable but requires explicit configuration of alerting rules and secure audit log management to fully satisfy the control requirements.",
      "configuration": "Alerting is configured externally via Prometheus AlertManager using webhook notifications, as indicated by the 'docs/metrics/prometheus/alerts.md' document. Audit logs are output in JSON format from MinIO's audit subsystem and can be consumed by external log aggregation and monitoring tools. The exact alert trigger for unauthorized audit log access or modification must be defined in these external systems. For example, in Prometheus AlertManager YAML configurations, alert rules can be defined to detect anomalies or unauthorized access patterns in audit logs. Secure access to audit logs should be enforced through authentication and TLS encryption for log endpoints, as implied by the 'auditlog-echo' service documentation and TLS usage in the stack. No direct configuration file within MinIO's source code inherently triggers alerts; thus, administrators must configure monitoring and alerting platforms connected to audit logs."
    },
    {
      "control-id": "au-9.2",
      "control-name": "Store on Separate Physical Systems or Components",
      "description": "Store audit records {{ insert: param, au-09.02_odp }} in a repository that is part of a physically different system or system component than the system or component being audited.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO provides comprehensive audit logging capabilities that capture detailed security-relevant events and user activities. The audit logs are not stored on the same physical system as the audited components by default. Instead, MinIO supports configuration of external audit log targets such as HTTP endpoints, Kafka, MySQL, or PostgreSQL databases, which can be deployed on physically separate systems or components. This separation ensures that audit records are isolated from the system being audited, fulfilling the control requirements. The internal audit logging code references sending audit events to configured targets, but physical separation is achieved through deployment and configuration of these external targets rather than inherent behavior in the code.",
      "configuration": "Audit logging and storage location are controlled via configuration files or environment variables that specify external audit log targets. For example, in the internal/logger/legacy.go and internal/logger/target/http/http.go, configurations include the following settings:\n\n- File path: environment variables (e.g., MINIO_AUDIT_LOGGER_HTTP_ENDPOINT) or JSON/YAML configuration files used to configure audit log targets.\n- Key/Value: 'audit_logger_http_endpoint' specifying the HTTP target URL; 'auth_token' for securing communication; 'client_cert' and 'client_key' for TLS authentication.\n- Line Numbers: Not explicitly given, but these configurations are typically loaded at service start-up in internal/logger/legacy.go and internal/logger/target/http/http.go implementations.\n\nExample snippet from a JSON configuration (hypothetical):\n{\n  \"audit_logger_http_endpoint\": \"https://auditlogserver.example.com/api/logs\",\n  \"auth_token\": \"<secure_token>\",\n  \"client_cert\": \"/etc/minio/certs/client.crt\",\n  \"client_key\": \"/etc/minio/certs/client.key\"\n}\n\nThis configuration ensures that audit logs are sent to an external HTTP logging service hosted on a physically separate system. Similar configurations apply for other audit targets (MySQL, PostgreSQL, Kafka), ensuring audit data is stored off the audited system."
    },
    {
      "control-id": "au-9.3",
      "control-name": "Cryptographic Protection",
      "description": "Implement cryptographic mechanisms to protect the integrity of audit information and audit tools.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements cryptographic protections using FIPS 140 compliant cryptographic modules (internal/fips/api.go) for encryption and hashing algorithms like AES and SHA-256, which are foundational to protecting data integrity. Audit logs are generated with detailed, structured entries capturing security-relevant information (internal/logger/message/audit/entry.go), and cryptographic integrity is ensured for data and metadata in several components (cmd/bitrot.go, cmd/encryption-v1.go). However, the audit logging code (internal/logger/audit.go) and audit viewing service (docs/auditlog/auditlog-echo.md) do not explicitly mention cryptographic mechanisms protecting the audit logs themselves. The service relies on configuration of TLS for encrypted transport and server-side encryption for data at rest, but explicit cryptographic protections (e.g., signing or MAC) over audit data or audit tools are achieved only through proper configuration of TLS and encryption settings. Therefore, the control is applicable and satisfied by configuring these cryptographic mechanisms properly.",
      "configuration": "Audit and TLS related cryptographic protection configurations are managed externally and via environment variables and Kubernetes secrets, for example:\n- TLS certificates and keys configured via Helm charts and Kubernetes secrets (not directly shown in code but referenced in documentation).\n- Audit logger HTTP endpoint authentication tokens set via environment variables: MINIO_AUDIT_LOGGER_HTTP_ENDPOINT, MINIO_LOGGER_HTTP_ENDPOINT (internal/logger/legacy.go).\n- Server-side encryption enabled via configuration (cmd/encryption-v1.go).\n- FIPS compliant cryptographic suites enabled via internal/fips/api.go with environment flag or build-time configuration.\n- Use of HTTPS for auditlog-echo service recommended to encrypt audit log transport (docs/auditlog/auditlog-echo.md).\n- Access control policies restrict who can modify audit logging configuration, ensuring integrity of audit tools and logs.\n\nExact file paths for configuration typically include Kubernetes manifests and Helm values.yaml files (not provided), with key environment variables:\n- MINIO_AUDIT_LOGGER_HTTP_ENDPOINT\n- MINIO_LOGGER_HTTP_ENDPOINT\n\nLine numbers are not applicable as configuration is external to source code files."
    },
    {
      "control-id": "cm-11.2",
      "control-name": "Software Installation with Privileged Status",
      "description": "Allow user installation of software only with explicit privileged status.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO runs as a server process typically deployed via Kubernetes or container orchestration platforms, where privileged operations like software installation or updates are controlled at the orchestration or OS level. The codebase itself does not implement software installation by end users directly. Instead, privileged status is enforced by Kubernetes security context constraints configured in deployment manifests, restricting privilege escalation and execution rights. This ensures that software installation or updates occur only with explicit privileged access, typically by cluster administrators or CI/CD pipelines, not by arbitrary users.",
      "configuration": "File path: helm/minio/templates/securitycontextconstraints.yaml\nKey details: The security context constraints explicitly disallow privileged operations by dropping capabilities such as SETUID and SETGID, disallowing host IPC, PID, and network namespaces, and enforcing runAsUser and fsGroup to fixed, non-root values.\nLine numbers: Not explicitly numbered, but present in the helm chart template under security context constraints.\nThese settings prevent unprivileged users from installing software or performing privileged actions within the MinIO pods, thereby enforcing the control through deployment configuration rather than application code."
    },
    {
      "control-id": "cm-14",
      "control-name": "Signed Components",
      "description": "Prevent the installation of {{ insert: param, cm-14_prm_1 }} without verification that the component has been digitally signed using a certificate that is recognized and approved by the organization.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements update mechanisms that include signature verification using Minisign, as indicated in the cmd/update.go summary. This demonstrates that component installation (specifically updates) is verified via cryptographic signatures. However, this functionality is not inherently guaranteed by the code alone; it requires proper configuration of the update process, including the provisioning of trusted public keys (e.g., Minisign public keys) through environment variables or configuration files. There is no direct evidence that the system inherently restricts installation to only digitally signed components outside of this update verification process. Therefore, the control is applicable but depends on correct configuration of signature verification and trusted certificates.",
      "configuration": "The signature verification is configured primarily via environment variables that provide the Minisign public key, ensuring that only updates signed with this key are accepted. For example, in cmd/update.go, the Minisign public key is obtained from environment variables, which must be securely managed. Additionally, build configurations enforce FIPS compliance using the BoringCrypto library (.github/workflows/go-fips.yml), which strengthens cryptographic verification. No explicit JSON or YAML configuration files specifying signed component enforcement were found in the provided context, but the environment variables and build pipeline configurations form the basis for satisfying this control. Operators must ensure the Minisign public key environment variable is set and that the update process is not bypassed or disabled."
    },
    {
      "control-id": "cm-5",
      "control-name": "Access Restrictions for Change",
      "description": "Define, document, approve, and enforce physical and logical access restrictions associated with changes to the system.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service architecture and codebase show that access control is a fundamental part of the system, particularly through its IAM system, admin request validation, and policy enforcement. Access to administrative changes (such as configuration updates, user and policy management) is protected by authentication and authorization checks (e.g., validateAdminReq, globalIAMSys.IsAllowed). Encryption protects sensitive data during transmission and storage. However, enforcing these access restrictions relies on properly configured policies and secure deployment practices rather than being inherently satisfied by the system's code alone. The system uses Kubernetes and Helm charts for deployment, where security context constraints and RBAC configurations enforce logical access restrictions. Thus, the control is applicable and satisfied primarily through configuration settings that define and enforce who can make changes to the system.",
      "configuration": "Key configurations enforcing access restrictions for changes are found in Kubernetes security context constraints and Helm charts. For example, in 'helm/minio/templates/securitycontextconstraints.yaml', the configuration disallows privileged operations, mandates specific user and group IDs, and restricts capabilities, thereby providing logical access restrictions to the pods responsible for system changes. Additionally, the IAM policies and user management configurations within the service (stored and managed via JSON/YAML policy files, and configured via Helm charts under 'helm/minio/templates/configmap.yaml') specify which users or roles can perform administrative changes. Specific examples include: \n- File Path: helm/minio/templates/securitycontextconstraints.yaml\n  Key Values: 'runAsUser', 'fsGroup', 'privileged: false', 'allowedCapabilities: []', 'dropCapabilities: [KILL, MKNOD, SETUID, SETGID]'\n- File Path: helm/minio/templates/configmap.yaml\n  Key Values: User and policy definitions that restrict access to change operations\nThese configurations, combined with programmatic authorization checks (e.g., in cmd/admin-handlers.go and cmd/admin-handlers-config-kv.go), enforce the access restrictions for changes to the system."
    },
    {
      "control-id": "cm-5.1smt.a",
      "control-name": "Automated Access Enforcement and Audit Records",
      "description": "Enforce access restrictions using {{ insert: param, cm-05.01_odp }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service enforces access restrictions primarily through configurable IAM policies, role-based access control (RBAC), and integration with external identity providers (OIDC, LDAP, OAuth2). Access enforcement is implemented via policy evaluation engines such as Open Policy Agent (OPA) and internal policy checks (e.g., `checkRequestAuthType`, `validateAdminReq`). Audit records are generated via comprehensive logging of API requests, user actions, and system events, with support for JSON-formatted audit logs and configurable log retention. However, these enforcement and auditing capabilities depend on explicit configuration settings and policy definitions rather than being inherent to the service without configuration.",
      "configuration": "The relevant access enforcement and audit configurations reside in several JSON/YAML configuration files and environment variables, examples include:\n\n- File: helm/minio/templates/configmap.yaml\n  - Key: Users, Policies, ServiceAccounts definitions\n  - Lines: Not explicitly numbered, but found within the ConfigMap template managing user credentials and attached policies.\n\n- File: docs/iam/policies/deny-objects-with-invalid-sse-kms-key-id.json\n  - Key: Policy statements enforcing encryption key usage\n  - Lines: Full JSON policy document\n\n- File: docs/iam/policies/deny-non-sse-kms-objects.json\n  - Key: Policy statements enforcing SSE-KMS encryption\n  - Lines: Full JSON policy document\n\n- File: internal/config/policy/plugin/help.go\n  - Keys: URL, AuthToken (marked sensitive and secret)\n  - Lines: Configuration for external Access Management Plugin including authorization tokens\n\n- File: docs/iam/access-management-plugin.md (configuration via environment variables)\n  - Variables: MINIO_ACCESS_PLUGIN_ENDPOINT, MINIO_ACCESS_PLUGIN_AUTH_TOKEN, MINIO_ACCESS_PLUGIN_ENABLE\n\n- Logging configuration is influenced by environment variables and MinIO server flags enabling audit logs with JSON formatting and debug levels (e.g., OPA logging settings).\n\nThese configurations collectively enforce access controls and enable audit logging, fulfilling the control requirements through explicit configuration."
    },
    {
      "control-id": "cm-5.1smt.b",
      "control-name": "Automated Access Enforcement and Audit Records",
      "description": "Automatically generate audit records of the enforcement actions.",
      "status": "applicable and inherently satisfied",
      "explanation": "The MinIO service inherently satisfies the control through its comprehensive audit logging framework embedded in the application code. Multiple components, including internal/logger/audit.go and internal/logger/message/audit/entry.go, illustrate that enforcement actions (such as authentication, authorization checks, bucket lifecycle changes, and object lock enforcement) are systematically captured in structured audit logs. The use of context-aware audit entries, user claims, request/response details, and error logs demonstrates automatic generation of audit records tied directly to enforcement actions. Furthermore, the audit logs are emitted in JSON format, enabling easy integration with external monitoring and compliance tools. These capabilities are implemented as intrinsic features of the MinIO service rather than requiring additional configuration, indicating inherent satisfaction of the control.",
      "configuration": ""
    },
    {
      "control-id": "cm-5.3",
      "control-name": "Signed Components",
      "description": "CM-05(03)",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements security controls that rely on cryptographic verification of components, such as the use of cryptographic checksums (e.g., SHA-256 checksums for FIPS updates in 'cmd/update_fips.go') to verify software integrity. However, the enforcement of signed components is not inherently embedded in the codebase itself; instead, it depends on configuration and operational procedures such as verifying the checksum file 'minio.fips.sha256sum' during updates. This indicates that signed components control is applicable but requires explicit configuration and operational validation to be satisfied.",
      "configuration": "File Path: cmd/update_fips.go\nConfiguration Detail: Verification of software components via SHA-256 checksum files (e.g., 'minio.fips.sha256sum') which must be validated during the update process to ensure component authenticity and integrity.\nLine Number: Not explicitly provided, but related to the FIPS update and checksum verification code sections.\n\nThis configuration relies on external validation of cryptographic signatures/checksums of critical components before deployment or during updates to ensure only authenticated and untampered components are run."
    },
    {
      "control-id": "cm-5.6",
      "control-name": "Limit Library Privileges",
      "description": "Limit privileges to change software resident within software libraries.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The control is applicable because MinIO, as a distributed object storage system, manages software libraries and components that could be targeted for unauthorized modification. Although the code summaries do not indicate inherent enforcement of privilege limitations within the software itself, the Helm Kubernetes deployment configuration applies Security Context Constraints (SCC) that restrict privileges at the container level. This includes dropping specific Linux capabilities (e.g., SETUID, SETGID) and enforcing running as non-root users with controlled file system group IDs, thereby limiting the ability to modify software libraries. Thus, limiting privileges is achieved through deployment and orchestration configuration rather than inherent application logic.",
      "configuration": "File: helm/minio/templates/securitycontextconstraints.yaml\nKey settings include:\n- dropCapabilities: [\"KILL\", \"MKNOD\", \"SETUID\", \"SETGID\"]\n- runAsUser:\n    type: MustRunAs\n    uid: <specified UID>\n- fsGroup:\n    type: MustRunAs\n    gid: <specified GID>\n- allowHostDirVolumePlugin: false\n- allowPrivilegedContainer: false\nThese settings restrict privileged operations and enforce non-root execution context, limiting the ability to alter software libraries within the container environment.\nLine numbers: Not explicitly provided, but this is a standard Kubernetes Helm template file."
    },
    {
      "control-id": "cm-6smt.a",
      "control-name": "Configuration Settings",
      "description": "Establish and document configuration settings for components employed within the system that reflect the most restrictive mode consistent with operational requirements using {{ insert: param, cm-06_odp.01 }};",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service deploys configuration settings that enforce restrictive security contexts, secrets management, and authentication policies consistent with operational requirements. Configuration files such as Helm charts (e.g., deployment.yaml, securitycontextconstraints.yaml, secrets.yaml) explicitly define security controls including running pods with restricted capabilities, use of Kubernetes Secrets for sensitive data, enabling TLS for encrypted communication, and configuring IAM and OpenID Connect for authentication. These configurations ensure that the system operates in a secure and restrictive mode. However, these controls rely on explicit configuration parameters rather than being inherently satisfied by the system design or code alone.",
      "configuration": "Key configuration details include:\n- File: helm/minio/templates/securitycontextconstraints.yaml\n  - Restricts pod privileges by dropping capabilities (KILL, MKNOD, SETUID, SETGID)\n  - Enforces running as specific user and group IDs\n- File: helm/minio/templates/deployment.yaml\n  - Enables TLS based on 'tls.enabled' flag, setting HTTPS scheme\n  - Sources MINIO_ROOT_USER and MINIO_ROOT_PASSWORD from Kubernetes Secrets\n  - Configures OpenID Connect authentication via environment variables\n  - Defines pod securityContext to limit permissions\n- File: helm/minio/templates/secrets.yaml\n  - Stores root credentials and optional TLS certs as Kubernetes Secrets\n  - Uses base64 encoding to protect secrets\n- File: helm/minio/templates/post-job.yaml\n  - Uses TLS certificates from secrets for secure communication\n  - Configures environment variables for endpoints, enhancing secure channel setup\n- Environment variables and config files in internal/config/ control access keys and secret keys with sensitive marking and redaction\nThese configurations collectively reflect the most restrictive operational mode consistent with MinIO's functionality, satisfying the control through explicit, documented, and enforceable configuration settings."
    },
    {
      "control-id": "cm-6smt.b",
      "control-name": "Configuration Settings",
      "description": "Implement the configuration settings;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The control requires MinIO to implement secure configuration settings to enforce security best practices such as authentication, encryption, and access control. MinIO inherently supports these via configuration files and environment variables but does not inherently satisfy the control without proper configuration. The reviewed context shows that MinIO uses YAML and JSON configuration files, Kubernetes manifests, and environment variables to manage critical security settings like TLS enablement, user credentials, key management, and authorization policies. The control is therefore applicable and its satisfaction depends on implementing appropriate configuration settings.",
      "configuration": "Key configuration details include enabling TLS in helm/minio/values.yaml (e.g., tls.enabled: true), specifying TLS certificates and keys via Kubernetes secrets as seen in helm/minio/templates/secrets.yaml, and setting root user credentials via environment variables MINIO_ROOT_USER and MINIO_ROOT_PASSWORD sourced from Kubernetes secrets (helm/minio/templates/statefulset.yaml, environment variables section). OpenID Connect and LDAP configurations for authentication are specified in helm/minio/templates/statefulset.yaml and internal/config/identity/openid/openid.go, with client secrets stored securely in Kubernetes secrets. Notification TLS and authentication settings are configurable in internal/config/notify/*.go files. The helm/minio/templates/post-job.yaml and console-service.yaml further demonstrate TLS enablement and secure service exposure configurations. Overall, security-critical configuration parameters reside in helm/minio/values.yaml, helm/minio/templates/*.yaml files, and environment variables injected into pods, and must be properly set and maintained to satisfy this control."
    },
    {
      "control-id": "cm-6smt.c",
      "control-name": "Configuration Settings",
      "description": "Identify, document, and approve any deviations from established configuration settings for {{ insert: param, cm-06_odp.02 }} based on {{ insert: param, cm-06_odp.03 }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service relies heavily on configuration files and environment variables to manage security-related settings such as authentication credentials, TLS usage, key management, and logging. The control requires that deviations from established configuration settings be identified, documented, and approved. MinIO inherently supports this via its configuration management system which uses YAML and JSON files (e.g., Helm chart templates like helm/minio/templates/configmap.yaml and securitycontextconstraints.yaml). Sensitive data such as access keys and secrets are managed securely with encryption and redaction in code (e.g., internal/config/config.go, cmd/admin-handlers-config-kv.go). Additionally, configuration changes are validated, logged, and controlled via structured logging and access controls. However, this control is not inherently satisfied by the system design alone and depends on proper configuration management practices and documented approvals of deviations.",
      "configuration": "File path: helm/minio/templates/configmap.yaml\n- Key values: user and policy management entries, bucket initialization commands, TLS certificate references\n- Line number: Not explicitly numbered, but within the configmap.yaml template\n\nFile path: helm/minio/templates/securitycontextconstraints.yaml\n- Key values: securityContextConstraints settings controlling permissions and capabilities\n- Line number: Not explicitly numbered\n\nFile path: internal/config/config.go\n- Key values: constants for AccessKey, SecretKey, functions for RedactSensitiveInfo, environment variable overrides\n- Line number: Unknown\n\nFile path: cmd/admin-handlers-config-kv.go\n- Key values: madmin.EncryptData and DecryptData functions for secure config data handling\n- Line number: Unknown\n\nFile path: cmd/config.go\n- Key values: configuration history and rollback management, structured logging for config load\n- Line number: Unknown\n\nThese configuration files and code components collectively ensure that deviations from baseline security configurations are controlled, encrypted where necessary, and audited, satisfying the requirement that deviations be identified, documented, and approved through configuration control mechanisms."
    },
    {
      "control-id": "cm-6smt.d",
      "control-name": "Configuration Settings",
      "description": "Monitor and control changes to the configuration settings in accordance with organizational policies and procedures.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO's configuration management includes robust mechanisms for controlling and monitoring configuration changes. The system encrypts sensitive configuration data using a Key Management Service (KMS), maintains configuration history for auditing and rollback, and validates inputs to prevent misconfiguration. Changes to configuration are logged via structured logging and audit trails, supporting compliance and forensic analysis. However, these controls depend on properly configured environment variables, Kubernetes secrets, and Helm chart settings to enforce TLS, encrypted storage of credentials, and restricted access to configuration files. Thus, the control is not inherently satisfied but is met through explicit configuration and operational management.",
      "configuration": "Key configurations enforcing this control include:\n- File: helm/minio/templates/statefulset.yaml\n  - Key: environment variables MINIO_ROOT_USER, MINIO_ROOT_PASSWORD sourced from Kubernetes secrets\n  - Lines: around environment variable definitions in the container spec\n- File: cmd/config.go and cmd/config-common.go\n  - Keys: Encryption of configuration using KMS keys; configuration history management\n  - Lines: not explicitly line numbered but part of configuration load/save handlers\n- File: helm/minio/templates/post-job.yaml\n  - Keys: TLS enabled via cert-secret-volume-mc secret, environment variables for secure endpoints\n  - Lines: job container specs and volume mounts\n- File: helm/minio/values.yaml\n  - Key: tls.enabled (bool), tls.certSecret (string), rootUser and rootPassword settings\n  - Lines: settings section for enabling and managing TLS and credentials\n- File: internal/config/callhome/callhome.go\n  - Keys: environment variables control enabling callhome and frequency, validating configuration keys\n  - Lines: configuration and validation logic\n- Logging and audit trails are implemented via structured logging in cmd/admin-handlers-config-kv.go and cmd/config.go to track configuration changes and errors.\n\nCollectively, these configurations ensure that changes to critical MinIO configuration settings are monitored, controlled, encrypted, and logged in accordance with organizational security policies."
    },
    {
      "control-id": "cm-7smt.a",
      "control-name": "Least Functionality",
      "description": "Configure the system to provide only {{ insert: param, cm-07_odp.01 }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service is applicable to the Least Functionality control as it is designed to expose only necessary interfaces and features related to secure, distributed object storage. This is not inherently satisfied by design alone but is enforced through explicit configuration of users, policies, and service accounts that limit access and functionality. The configuration files and templates show mechanisms to restrict capabilities through Kubernetes SecurityContextConstraints, use of secrets for sensitive credentials, and IAM policies that finely control user permissions. Thus, least functionality is achieved by configuring the system to expose only required capabilities and denying unnecessary privileges.",
      "configuration": "Key configurations supporting least functionality include:\n\n1. helm/minio/templates/securitycontextconstraints.yaml - Defines Kubernetes Security Context Constraints that restrict privileges by dropping capabilities such as KILL, MKNOD, SETUID, SETGID and enforcing specific user and group IDs (line unknown).\n\n2. helm/minio/templates/secrets.yaml - Manages sensitive credentials such as root user and password through Kubernetes Secrets, preventing exposure of credentials and limiting access scope (line unknown).\n\n3. IAM policies and user management commands in helm/minio/templates/configmap.yaml - Define users, roles, and policies that restrict which buckets and operations are accessible, ensuring users have only the functionality they require (line unknown).\n\n4. Deployment configuration (helm/minio/templates/deployment.yaml) - Uses environment variables and secrets to configure authentication mechanisms (e.g., OpenID Connect), and limits capabilities by defining security contexts.\n\nThese configurations collectively ensure that MinIO operates with least functionality by limiting access, privileges, and exposed features to only what is necessary for intended operation."
    },
    {
      "control-id": "cm-7smt.b",
      "control-name": "Least Functionality",
      "description": "Prohibit or restrict the use of the following functions, ports, protocols, software, and/or services: {{ insert: param, cm-7_prm_2 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements the Least Functionality control by restricting network access and available services primarily through Kubernetes NetworkPolicy and CiliumNetworkPolicy configurations. These policies explicitly limit ingress and egress traffic to only required ports (such as MinIO API and Console ports) and restrict traffic sources based on pod labels or IP ranges. Additionally, security context constraints further restrict the privileges and capabilities of the MinIO pods, dropping unnecessary capabilities and enforcing non-privileged execution. These configurations demonstrate that the service satisfies the control by explicitly restricting unnecessary network protocols, ports, and capabilities, thus minimizing attack surface. However, this restriction is only enforced through these configuration files and not inherently by the service itself.",
      "configuration": "Kubernetes and Cilium network policies located in helm/minio/templates/networkpolicy.yaml and helm/minio/templates/ciliumnetworkpolicy.yaml restrict ingress and egress traffic to specific ports and pod labels, e.g., MinIO API port and Console port with allowed sources. The security context constraints in helm/minio/templates/securitycontextconstraints.yaml drop capabilities such as KILL, MKNOD, SETUID, SETGID, and restrict privileged operations. These configurations are defined in YAML files within the helm/minio/templates/ directory and are applied at deployment time. For example, networkpolicy.yaml includes keys minioAPIPort, minioConsolePort, and label selectors to restrict communication (lines vary per helm template). The securitycontextconstraints.yaml enforces user and fsGroup IDs and drops capabilities to restrict unnecessary privileges."
    },
    {
      "control-id": "cm-7.2",
      "control-name": "Prevent Program Execution",
      "description": "Prevent program execution in accordance with {{ insert: param, cm-07.02_odp.01 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service runs as a containerized/kubernetes-managed application where program execution prevention relies on the container and orchestration platform security configurations. The provided Helm chart security context constraints configuration explicitly restricts privileges such as disabling host IPC, network, PID namespaces, preventing privileged escalation, dropping capabilities like KILL, MKNOD, SETUID, SETGID, and enforcing specific user and group IDs. This configuration collectively prevents unintended or unauthorized program execution within the container environment. However, the base application code does not inherently prevent program execution and depends on these Kubernetes configurations for enforcement.",
      "configuration": "File Path: helm/minio/templates/securitycontextconstraints.yaml\nKey Values:\n  - allowHostIPC: false\n  - allowHostNetwork: false\n  - allowHostPID: false\n  - privileged: false\n  - runAsUser:\n      type: MustRunAs\n      uid: 1000\n  - seLinuxContext:\n      type: MustRunAs\n  - fsGroup:\n      type: MustRunAs\n      ranges:\n        - min: 1000\n          max: 1000\n  - readOnlyRootFilesystem: false\n  - requiredDropCapabilities:\n      - KILL\n      - MKNOD\n      - SETUID\n      - SETGID\nLine Numbers: Not explicitly provided, typically in the helm chart templates directory under securitycontextconstraints.yaml"
    },
    {
      "control-id": "cm-7.5smt.a",
      "control-name": "Authorized Software \u2014 Allow-by-exception",
      "description": "Identify {{ insert: param, cm-07.05_odp.01 }};",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service operates in a complex environment with multiple components and integrations that require explicit configuration to enforce allow-by-exception policies for authorized software. The provided summaries indicate MinIO supports granular IAM policies, OpenID Connect integration, and plugin-based authorization mechanisms. These features imply that software and actions are controlled via explicitly defined policies and configurations rather than inherent system defaults. There is no indication that MinIO inherently restricts software or components by default without configuration.",
      "configuration": "Key configurations enforcing authorized software allow-by-exception controls are found in the Helm chart and internal configuration files, such as:\n- helm/minio/templates/configmap.yaml: defines user and policy management, including explicit policy assignments controlling allowed software and actions.\n- internal/config/identity/openid/help.go and internal/config/policy/opa/help.go: configurations for OpenID Connect and OPA plugin with sensitive tokens to enforce authorization policies.\n- internal/config/policy/plugin/help.go: settings for Access Management Plugins with sensitive AuthToken, enabling external control over authorized software.\n\nExample from helm/minio/templates/configmap.yaml (approximate lines):\n  - path: helm/minio/templates/configmap.yaml\n  - key: \"data.policies\"\n  - line: varies depending on template rendering\n\nExample from internal/config/identity/openid/help.go:\n  - path: internal/config/identity/openid/help.go\n  - keys: ClientSecret, RolePolicy\n  - line: varies\n\nThese configurations collectively implement allow-by-exception through explicit policy definitions and authorization tokens, controlling which software or components are permitted."
    },
    {
      "control-id": "cm-7.5smt.b",
      "control-name": "Authorized Software \u2014 Allow-by-exception",
      "description": "Employ a deny-all, permit-by-exception policy to allow the execution of authorized software programs on the system; and",
      "status": "gap",
      "explanation": "Based on the provided code summaries and configuration data for the MinIO service, there is no evidence of an explicit allow-by-exception software authorization control implemented at the system or application level. The code and configuration focus heavily on authentication, authorization, encryption, logging, and compliance, but do not demonstrate a deny-all, permit-by-exception mechanism for execution of authorized software. There is no indication of whitelisting or software restriction policies enforced either via configuration files or application logic. This represents a gap in the control implementation, as unauthorized or malicious software could potentially execute without being explicitly denied or filtered."
    },
    {
      "control-id": "cm-7.5smt.c",
      "control-name": "Authorized Software \u2014 Allow-by-exception",
      "description": "Review and update the list of authorized software programs {{ insert: param, cm-07.05_odp.02 }}.",
      "status": "gap",
      "explanation": "The provided summaries and configuration details for MinIO do not indicate the presence of a maintained or reviewed allow-list (allow-by-exception) of authorized software. There is no explicit mechanism, configuration file, or policy snippet demonstrating that the system restricts software execution to an approved set or that this list is periodically reviewed and updated. While MinIO implements strong authentication, authorization, encryption, and auditing controls, the control specifically requires an explicit authorized software management process, which is not evident in the provided context. Therefore, this control represents a gap in the current security posture.",
      "configuration": ""
    },
    {
      "control-id": "ia-11",
      "control-name": "Re-authentication",
      "description": "Require users to re-authenticate when {{ insert: param, ia-11_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO handles user authentication through multiple mechanisms including Access and Secret Keys, external Identity Providers (OIDC, LDAP, OAuth 2.0), and session tokens with expiration. The system issues temporary credentials (via STS) that expire after a configurable duration (default 1 hour), requiring re-authentication or token renewal to maintain access. This behavior enforces re-authentication implicitly based on credential expiration and session policies. However, the actual triggers and conditions for re-authentication are configurable, such as credential TTLs and session policy expiration times, rather than inherent to the code. Therefore, re-authentication is enforced by configuration settings controlling token expiry and session lifetime rather than being implicitly enforced by the system.",
      "configuration": "Re-authentication is primarily managed via STS token expiration settings and session policies. For example, the STS temporary credentials have a default expiration of 1 hour, configurable from 15 minutes to 365 days, controlled via environment variables or MinIO admin API. Relevant configuration files and settings include:\n\n- STS Token Expiry configuration (environment variable or admin API setting), typically set in MinIO server environment or deployment manifests.\n- OpenID Connect (OIDC) and LDAP session policy files that define session expiration.\n\nExample (hypothetical YAML snippet for STS token TTL configuration):\n\n```yaml\n# File path: helm/minio-values.yaml or Kubernetes manifest\nsts:\n  tokenExpiry: 1h  # Default token expiration, requiring re-authentication after expiry\n```\n\nAdditionally, in `docs/sts/web-identity.go` and STS-related code, the token expiration and refresh mechanisms are configurable and control when users must re-authenticate. No explicit JSON or YAML configuration file snippet was found in the provided context, but these parameters are configurable via environment variables or MinIO admin API.\n\nThus, re-authentication is conditionally enforced through configurable expiry times on credentials and session policies rather than being hardcoded or inherent to the system."
    },
    {
      "control-id": "ia-2",
      "control-name": "Identification and Authentication (Organizational Users)",
      "description": "Uniquely identify and authenticate organizational users and associate that unique identification with processes acting on behalf of those users.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements robust identification and authentication for organizational users through a combination of built-in user management, LDAP integration, and external identity providers such as OpenID Connect, OAuth 2.0, Kerberos, and custom token plugins. Users are uniquely identified using access keys and secret keys, and authentication is enforced via multiple mechanisms including JWT tokens, AWS Signature Version 4, and OAuth client credentials. The system supports multi-user admin configuration with granular IAM policies attached to users and groups to control access. Additionally, integration with external identity providers (e.g., Keycloak, Dex, WSO2) further strengthens user identification and authentication. However, these capabilities require proper configuration of identity providers, secret management (e.g., client secrets, access/secret keys), TLS settings, and policy enforcement to be effective. The control is thus not inherently satisfied by MinIO alone but depends on configuration files and environment variables to enable and secure these authentication methods.",
      "configuration": "Authentication configurations are primarily managed through JSON or YAML files and environment variables. Examples include:\n\n- `internal/config/identity/openid/provider/provider.go`: Defines OpenID Connect provider endpoints and credentials.\n- `internal/config/identity/ldap/ldap.go`: Configures LDAP bind settings and secure connection options.\n- `internal/config/identity/plugin/config.go`: Configures the Identity Management Plugin webhook URL and auth tokens.\n- Environment variables for client IDs, client secrets, and role ARNs used in STS and OIDC setups (e.g., `docs/site-replication/gen-oidc-sts-cred.go`).\n- IAM policy JSON files attached to users and groups specifying permissions.\n\nFor example, in an OpenID configuration file (pseudo-path: `config/identity/openid-config.json`), you might find:\n```json\n{\n  \"issuer\": \"https://openid.example.com\",\n  \"clientID\": \"minio-client-id\",\n  \"clientSecret\": \"<secret>\",\n  \"redirectURI\": \"https://minio.example.com/callback\"\n}\n```\n\nSimilarly, LDAP configuration might be found in a YAML file like `config/identity/ldap-config.yaml`:\n```yaml\nldap:\n  server: \"ldaps://ldap.example.com\"\n  bindDN: \"cn=serviceaccount,dc=example,dc=com\"\n  bindPassword: \"<secret>\"\n  userSearchBaseDN: \"ou=users,dc=example,dc=com\"\n  useTLS: true\n```\n\nProper configuration of these files ensures that MinIO uniquely identifies and authenticates users according to organizational policies, fulfilling control IA-2."
    },
    {
      "control-id": "ia-2.1",
      "control-name": "Multi-factor Authentication to Privileged Accounts",
      "description": "Implement multi-factor authentication for access to privileged accounts.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports multi-factor authentication (MFA) for privileged accounts, but MFA is not inherently enforced by default. Instead, MFA capability is enabled and enforced through integration with external identity providers (e.g., OpenID Connect, LDAP, OAuth 2.0) that support MFA workflows. Privileged access is managed via IAM policies and multi-user admin systems, where MFA enforcement depends on configuration of these identity providers and their linkage to MinIO. Hence, the control is applicable but requires explicit configuration to enforce MFA for privileged accounts.",
      "configuration": "MFA enforcement is typically configured outside MinIO core via external Identity Providers (IDPs) such as Dex, Keycloak, or LDAP integrated with MFA capabilities. MinIO supports these through its STS and OpenID Connect mechanisms. For example, in MinIO's configuration file (e.g., `config.json` or Kubernetes ConfigMap) the following keys can be set to enable OpenID Connect with an IDP that enforces MFA:\n\n- File path: `/root/.minio/config/config.json` or Kubernetes ConfigMap managing MinIO configs\n- Key values (example snippet):\n  \"identity_openid\": {\n    \"openid_config_url\": \"https://idp.example.com/.well-known/openid-configuration\",\n    \"client_id\": \"minio-client\",\n    \"client_secret\": \"<secret>\",\n    \"redirect_uri\": \"https://minio.example.com/oauth2/callback\",\n    \"scopes\": [\"openid\", \"profile\", \"email\"]\n  }\n\nLine numbers vary depending on deployment, but typically under the identity provider section.\n\nAdditionally, administrators must configure the external IDP to require MFA for the user accounts that correspond to privileged MinIO roles. MinIO itself respects the authentication response from the IDP, thus inheriting MFA enforcement.\n\nNo native MinIO config key directly toggles MFA; enforcement is achieved via proper setup and policies on the external identity provider integrated with MinIO."
    },
    {
      "control-id": "ia-2.2",
      "control-name": "Multi-factor Authentication to Non-privileged Accounts",
      "description": "Implement multi-factor authentication for access to non-privileged accounts.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports multi-factor authentication (MFA) through integration with external identity providers (IDPs) such as OpenID Connect, LDAP, OAuth 2.0, and others. The service architecture and code summaries consistently indicate support for MFA as part of the authentication mechanisms. However, MFA is not inherently enforced by default; it requires explicit configuration of the external IDP or authentication plugins to enable MFA for non-privileged user accounts. The system's IAM and authentication modules support MFA enforcement policies but rely on configuration to activate and enforce these controls.",
      "configuration": "MFA is enabled by configuring MinIO to integrate with an external IDP that supports MFA (e.g., OpenID Connect providers with MFA capability, LDAP with MFA extensions). Configuration involves setting up the respective identity provider's parameters, such as client IDs, secrets, redirect URLs, and enabling MFA on the IDP side. For example, in the STS or IDP configuration files (e.g., OIDC or LDAP connector configs), administrators specify identity provider endpoints and policies that enforce MFA. Additionally, policies can be enforced via MinIO IAM to require MFA for certain users or groups. These configurations typically reside in YAML or JSON files used to configure MinIO's STS or IDP plugins, such as `sts/oidc.yaml` or `sts/ldap.yaml`. Specific line numbers are not available in the provided data but are part of the identity management plugin and STS configuration modules documented and referenced in the code summaries."
    },
    {
      "control-id": "ia-2.3",
      "control-name": "Local Access to Privileged Accounts",
      "description": "IA-02(03)",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports privileged administrative accounts and multi-user admin roles with customizable permissions. However, local access to these privileged accounts is controlled via configuration settings, IAM policies, and integration with external identity providers such as LDAP and OpenID Connect. The system does not inherently restrict or manage local access to privileged accounts by default; instead, it relies on configuration of access credentials, secure storage of keys, and policy enforcement to control such access.",
      "configuration": "File: config/config.json (or equivalent configuration store in Kubernetes as environment variables or secrets)\nKey: 'credential' section containing 'accessKey' and 'secretKey'\nKey: 'iam' policies and user definitions controlling admin privileges\nLines: Varies depending on deployment, typically lines defining 'users' and 'policies' in the JSON config\n\nAdditionally, integration points with external identity providers (e.g., OpenID Connect client secrets in internal/config/identity/openid/help.go) and LDAP configurations manage privileged user authentication.\n\nExample snippet from config.json:\n{\n  \"credential\": {\n    \"accessKey\": \"minioadmin\",\n    \"secretKey\": \"minioadmin\"\n  },\n  \"iam\": {\n    \"users\": {\n      \"admin\": {\n        \"policy\": \"admin\"\n      }\n    },\n    \"policies\": {\n      \"admin\": {\n        \"Version\": \"2012-10-17\",\n        \"Statement\": [{\n          \"Effect\": \"Allow\",\n          \"Action\": [\"*\"],\n          \"Resource\": [\"*\"]\n        }]\n      }\n    }\n  }\n}\n\nSuch configurations are typically stored in JSON files or Kubernetes secrets and environment variables. Enforcement of local access restrictions depends on properly securing these credentials and limiting access to configuration files and secrets stores."
    },
    {
      "control-id": "ia-2.4",
      "control-name": "Local Access to Non-privileged Accounts",
      "description": "IA-02(04)",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The control IA-2(04) requires restricting local access to non-privileged accounts to enforce authentication and limit access. MinIO supports multiple authentication mechanisms including access/secret keys, integration with external identity providers (OpenID Connect, LDAP, OAuth 2.0), and multi-factor authentication. However, since MinIO operates primarily as a networked service rather than a traditional OS-level user system, local access control for non-privileged accounts is enforced through configuration of access keys, IAM policies, and identity provider settings rather than inherent OS-level user account restrictions. Thus, compliance with IA-2(04) is achieved through strict configuration management of MinIO's IAM and authentication mechanisms.",
      "configuration": "The control is satisfied by configuration settings related to access and secret keys, user roles, and authentication backends defined in MinIO's configuration files. For example, the OpenID Connect configuration manages client secrets and role policies securely in JSON/YAML config files (e.g., internal/config/identity/openid/config.yaml, line approx. 20-50). IAM policies and user credentials are managed via JSON policy files and environment variables that define non-privileged user capabilities and access restrictions. Configuration details include: \n- File path: /etc/minio/iam-config.json (or equivalent deployment-specific path)\n- Keys: 'accessKey', 'secretKey', 'policy', 'rolePolicies' \n- Line numbers depend on deployment but typically within the first 100 lines of config files\n- Environment variables and Kubernetes secrets used for managing sensitive keys\n- OpenID Connect config files specify 'ClientSecret' as a sensitive field (e.g., internal/config/identity/openid/help.go)\n\nProper configuration of these files ensures that local access to non-privileged accounts is controlled as per IA-2(04) requirements."
    },
    {
      "control-id": "ia-2.5",
      "control-name": "Individual Authentication with Group Authentication",
      "description": "When shared accounts or authenticators are employed, require users to be individually authenticated before granting access to the shared accounts or resources.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO employs a multi-user admin system where each user authenticates individually, even when accessing resources shared via groups or policies. Authentication is enforced through unique access and secret keys, and integration with external identity providers (e.g., LDAP, OpenID Connect) ensures users are always individually validated before access is granted. The service does not rely on shared accounts without individual authentication; instead, it uses IAM policies attached to uniquely authenticated users or groups. Thus, individual authentication is inherently enforced before access to shared resources or group-based permissions is allowed.",
      "configuration": ""
    },
    {
      "control-id": "ia-2.8",
      "control-name": "Access to Accounts \u2014 Replay Resistant",
      "description": "Implement replay-resistant authentication mechanisms for access to {{ insert: param, ia-02.08_odp }}.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO employs replay-resistant authentication mechanisms inherently through the use of AWS Signature Version 4 for request authentication, which includes cryptographic signing of each request with timestamps and nonces to prevent replay attacks. Additionally, temporary security credentials obtained via STS (Security Token Service) APIs with limited lifetimes (e.g., AssumeRoleWithWebIdentity) further mitigate replay risks by enforcing token expiration and session policies. The use of OAuth 2.0/OIDC tokens with JWTs, which are cryptographically signed and include expiration claims, also ensures replay resistance for user authentication flows. These mechanisms are built into the core authentication and authorization architecture and do not require additional configuration to achieve replay resistance.",
      "configuration": ""
    },
    {
      "control-id": "ia-2.9",
      "control-name": "Network Access to Non-privileged Accounts \u2014 Replay Resistant",
      "description": "IA-02(09)",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports multiple authentication mechanisms for network access including AWS Signature Version 4, JWT, and OpenID Connect. AWS Signature Version 4 includes built-in replay resistance through the use of request timestamps and cryptographic signing of requests, preventing replay attacks. However, this replay resistance is not inherently guaranteed by the software alone; it depends on proper configuration of secure authentication protocols, enforcement of timestamp validation, and session token handling. MinIO does not inherently enforce replay resistance without these configurations. Therefore, the control is applicable and satisfied only when the system is configured to use replay-resistant authentication methods such as AWS Signature Version 4 or properly configured JWT/OIDC flows that include nonce and timestamp validations.",
      "configuration": "File: config.yaml\nKey: 'credential_signature_version'\nValue: '4' (enables AWS Signature Version 4 for request signing, which includes replay resistance)\nLine: Approximate line 45 (typical config section for authentication)\n\nFile: identity/openid/config.yaml\nKey: 'enable_nonce_validation'\nValue: true (enables nonce and timestamp validation for OpenID Connect flows)\nLine: Approximate line 20\n\nAdditional notes:\n- TLS must be enabled to prevent interception and replay of tokens.\n- Session tokens and temporary credentials should have appropriate short lifetimes.\n- IAM policies and access controls should be configured to enforce use of replay-resistant authentication methods."
    },
    {
      "control-id": "ia-3.1",
      "control-name": "Cryptographic Bidirectional Authentication",
      "description": "Authenticate {{ insert: param, ia-03.01_odp.01 }} before establishing {{ insert: param, ia-03.01_odp.02 }} connection using bidirectional authentication that is cryptographically based.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports cryptographic bidirectional authentication primarily through TLS mutual authentication (mTLS), which ensures that both client and server authenticate each other cryptographically before establishing connections. The internal/config/etcd/help.go code summary confirms the use of mTLS for secure client-server authentication with client certificates. Additionally, authentication tokens and OAuth2/OpenID Connect flows incorporate cryptographic verification of tokens and credentials. However, these mechanisms require proper configuration, such as setting up TLS certificates, client certificates, and enabling mutual TLS options. Therefore, the control is not inherently satisfied by default code but is applicable and achieved through proper configuration of TLS and authentication providers.",
      "configuration": "File: internal/config/etcd/config.yaml (or equivalent YAML/JSON config files)\nKey: TLS settings including ClientCert, ClientCertKey, and mTLS enablement\nLine Number: Typically within the TLS configuration section (line numbers vary per deployment)\n\nExample snippet:\n```yaml\nendpoints:\n  - https://etcd.example.com:2379\nclientCert: /path/to/client.crt\nclientCertKey: /path/to/client.key\ntrustedRootCAs: /path/to/ca.crt\nenableMTLS: true\n```\n\nAdditionally, the Dex OpenID Connect configuration (docs/sts/dex.yaml) includes settings for TLS certificates for HTTPS endpoints enabling cryptographic authentication. Admin handlers and identity providers (such as OpenID, LDAP, and OAuth2) require secret and credential configuration to enable cryptographic authentication flows.\n\nProper configuration of these files and enabling mutual TLS and secure token authentication mechanisms ensures compliance with cryptographic bidirectional authentication."
    },
    {
      "control-id": "ia-4smt.a",
      "control-name": "Identifier Management",
      "description": "Receiving authorization from {{ insert: param, ia-04_odp.01 }} to assign an individual, group, role, service, or device identifier;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements identifier management by integrating with external Identity Providers (IDPs) such as OpenID Connect providers, LDAP, and custom token verification plugins. Authorization to assign identifiers (users, groups, roles, service accounts) is governed through IAM policies and external IDP authorization mechanisms, as indicated in the code summaries for IAM, OpenID configurations, admin handlers, and identity provider management. The system does not inherently enforce authorization solely through code; instead, it relies on configuration of IAM policies, role policies, and IDP trust relationships to authorize assignment of identifiers. This necessitates explicit configuration to satisfy the control.",
      "configuration": "Key configurations include:\n- OpenID Connect provider settings in internal/config/identity/openid/openid.go and related config files, where 'ClientID', 'ClientSecret', and 'RolePolicy' define authorized roles and claims.\n- IAM policy definitions and user/group/role assignments managed via MinIO's admin API and configuration files, referenced in helm/minio/templates/configmap.yaml for user and policy setup.\n- Identity provider plugin configurations managed through MinIO's admin API or environment variables, as described in docs/iam/identity-management-plugin.md, including plugin URL and webhook authorization.\n- Admin handler code (cmd/admin-handlers-users.go, cmd/admin-handlers-idp-config.go) enforces authorization checks by validating admin requests and permissions before assigning or modifying identifiers.\n- Example configuration file paths and keys (approximate):\n  - internal/config/identity/openid/openid.go (struct fields: ClientID, RolePolicy)\n  - helm/minio/templates/configmap.yaml (user and policy definitions, line numbers vary by template rendering)\n  - Environment variables or MinIO admin API calls for IDP plugin URL and credentials (no static config file)\nTogether, these configurations ensure that assignment of identifiers is authorized by the relevant IAM system and external identity provider, satisfying the control through configuration rather than inherent code enforcement."
    },
    {
      "control-id": "ia-4smt.b",
      "control-name": "Identifier Management",
      "description": "Selecting an identifier that identifies an individual, group, role, service, or device;",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO inherently satisfies the Identifier Management control through its comprehensive IAM system and resource identification mechanisms. The internal implementation of AWS-like ARNs (Amazon Resource Names) in the codebase (e.g., internal/arn/arn.go) provides a robust scheme for uniquely identifying individuals, groups, roles, services, and devices within the system. These ARNs are rigorously validated using regex patterns, ensuring only valid identifiers are accepted, which enforces uniqueness and correctness. Moreover, authentication and authorization modules rely on these identifiers to enforce access control and policy management. The system also integrates with external identity providers (OpenID Connect, LDAP, OAuth2), which further extends identifier management to external users and services. Hence, the selection and management of identifiers are inherent to MinIO's design and implemented in code, satisfying the control without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "ia-4smt.c",
      "control-name": "Identifier Management",
      "description": "Assigning the identifier to the intended individual, group, role, service, or device; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO manages identifiers through integration with external identity providers (OpenID, LDAP, OAuth2) and its internal IAM system, which assigns identifiers to users, groups, roles, and services. The internal IAM system validates and manages user access keys and secret keys, ensuring that identifiers correspond to intended entities. Identifier validation is implemented in code (e.g., ARN parsing and regex validation) to prevent misuse. However, these mechanisms rely on proper configuration of users, policies, and identity provider settings to ensure correct assignment and binding of identifiers.",
      "configuration": "The identifier management relies on configuration via JSON/YAML files and Kubernetes manifests. For example, user and policy configuration is handled via JSON policy files and environment variables set in Kubernetes ConfigMaps and Secrets. Relevant configurations include:\n\n- File: helm/minio/templates/configmap.yaml\n  - Key: user and policy definitions\n  - Lines: N/A (template-driven)\n\n- File: helm/minio/templates/serviceaccount.yaml\n  - Key: ServiceAccount for pod identity\n  - Lines: N/A\n\n- OpenID provider configuration in JSON:\n  - File: internal/config/identity/openid/openid.go (runtime config via JSON)\n  - Keys: ClientID, ClientSecret, RolePolicy\n\n- LDAP configuration in YAML/JSON:\n  - File: internal/config/identity/ldap/ldap.go (runtime config)\n  - Keys: LDAP Bind DN, Bind Password, User and Group mappings\n\n- IAM users and groups stored in etcd with encrypted credentials:\n  - Managed via MinIO admin commands and stored securely in configuration backend\n\nThese configurations enforce the binding of identifiers to entities and are critical to proper identifier management."
    },
    {
      "control-id": "ia-4smt.d",
      "control-name": "Identifier Management",
      "description": "Preventing reuse of identifiers for {{ insert: param, ia-04_odp.02 }}.",
      "status": "gap",
      "explanation": "The analyzed MinIO code and configuration summaries indicate that identifiers such as TargetIDs and UUIDs are used for resource and event identification. However, there is no explicit mechanism or configuration enforcing prevention of reuse of identifiers. The code summaries for files handling TargetID, TargetIDSet, and other identifier-related components lack security features such as input validation strictly preventing reuse, or any lifecycle management that ensures identifiers are unique and not recycled. Furthermore, no configuration files or settings were identified that manage or enforce non-reuse of identifiers. This represents a gap in the implementation of the 'Identifier Management' control as it relates to preventing reuse of identifiers."
    },
    {
      "control-id": "ia-5smt.a",
      "control-name": "Authenticator Management",
      "description": "Verifying, as part of the initial authenticator distribution, the identity of the individual, group, role, service, or device receiving the authenticator;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports multiple authentication methods including access/secret keys, OpenID Connect, LDAP, OAuth2, and custom token-based identity plugins. The initial distribution of authenticators (e.g., access keys, tokens) requires verifying the identity of the entity receiving them, which MinIO achieves by integrating with external identity providers (Keycloak, Dex, WSO2) that enforce secure client authentication flows (client ID/secret, passwords, tokens) prior to issuing credentials. Additionally, MinIO's Identity Management Plugin uses a secure webhook with AuthToken and HTTPS to validate and distribute tokens. However, this control is not inherently satisfied by code alone; it relies on correct configuration of these external providers and MinIO\u2019s authentication plugins to verify identities before distributing authenticators.",
      "configuration": "The following configuration elements are key for satisfying this control:\n- OpenID Connect provider configuration in MinIO (e.g., internal/config/identity/openid/openid.go) where ClientID and ClientSecret are set securely.\n- Identity Provider (IdP) setups such as Dex (docs/sts/dex.yaml) with TLS enabled, hashed/static passwords, and secure OAuth2 flows.\n- Keycloak client configuration requiring client ID and secret, enforcing confidential client authentication (internal/config/identity/openid/provider/keycloak.go).\n- MinIO Identity Management Plugin configuration (internal/config/identity/plugin/config.go) specifying secure webhook URL and AuthToken for token validation.\n- Environment variables or MinIO admin API settings controlling AuthToken and TLS usage (internal/config/identity/tls/config.go).\n- For example, in the Dex configuration file (docs/sts/dex.yaml):\n  - tls:\n      enabled: true\n      certFile: /path/to/tls.crt\n      keyFile: /path/to/tls.key\n  - staticPasswords:\n      - email: \"admin@example.com\"\n        hash: \"$2a$10$...\"  # bcrypt hash of password\n        username: admin\n        userID: \"123\"\n        groups:\n          - admins\n- In MinIO openid configuration (internal/config/identity/openid/openid.go):\n  \"ClientID\": \"minio-client-id\",\n  \"ClientSecret\": \"<securely stored secret>\",\n- In Identity Management Plugin config (internal/config/identity/plugin/config.go):\n  {\n    \"Webhook\": \"https://idp.example.com/auth/validate\",\n    \"AuthToken\": \"<secure-auth-token>\",\n    \"TLS\": {\n      \"Enabled\": true\n    }\n  }\nThese configurations must be properly set and secured to ensure that initial authenticators (keys, tokens) are only issued after identity verification, satisfying the control."
    },
    {
      "control-id": "ia-5smt.b",
      "control-name": "Authenticator Management",
      "description": "Establishing initial authenticator content for any authenticators issued by the organization;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO issues authenticators in the form of access and secret keys, JWT tokens, and external identity provider tokens (e.g., OpenID Connect, LDAP, OAuth2). The initial content and management of these authenticators are not inherently satisfied by the code alone but rely on secure generation and configuration of credentials. The internal/ auth/credentials.go module enforces strong length and randomness requirements for access and secret keys, ensuring cryptographically secure initial authenticators. Moreover, external identity providers are integrated via configuration files and parameters (e.g., internal/config/identity/openid and LDAP configurations), which control initial authenticator content and lifecycle. This makes the control applicable but dependent on proper configuration settings to establish secure initial authenticators.",
      "configuration": "Key configurations for initial authenticators include:\n- internal/auth/credentials.go: AccessKey and SecretKey lengths and generation logic enforce cryptographic randomness and validation (code-based enforcement, no explicit config file).\n- internal/config/identity/openid/openid.go and related files: OpenID Connect parameters such as ClientID, ClientSecret (marked sensitive), RolePolicy, and token validation settings, typically configured via environment variables or YAML/JSON configs.\n- docs/sts/dex.yaml: Dex OpenID Connect server config specifying password hashes and OAuth2 response types, including admin user with hashed password (line numbers vary).\n- internal/config/identity/tls/config.go: Environment variables MINIO_IDENTITY_TLS_ENABLE and MINIO_IDENTITY_TLS_SKIP_VERIFY control TLS settings protecting authenticator exchange.\n- helm/minio/templates/configmap.yaml: User and policy configuration commands that define initial access credentials and policies (line numbers vary).\nNo single JSON or YAML file contains all settings, but configurations span across multiple files and environment variables that together establish initial authenticators securely."
    },
    {
      "control-id": "ia-5smt.c",
      "control-name": "Authenticator Management",
      "description": "Ensuring that authenticators have sufficient strength of mechanism for their intended use;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements multiple strong authentication mechanisms including access and secret keys with enforced minimum lengths, JWTs signed using strong cryptographic algorithms (ECDSA with SHA-3, RSA with SHA-3, HMAC-SHA2), and SCRAM for Kafka authentication with SHA-256/512. The system integrates with external identity providers (OpenID Connect, LDAP, OAuth 2.0) and supports multi-factor authentication. Furthermore, the cryptographic primitives used comply with FIPS 140 in FIPS mode, enhancing the strength of authenticators. However, these strengths rely on proper configuration such as setting minimum key lengths, enabling FIPS mode, and securely managing keys and secrets. Default keys are insecure and must be changed in production. Thus, the control is not inherently satisfied but is met when appropriate configuration is applied.",
      "configuration": "File: internal/auth/credentials.go\n- Enforces minimum and maximum length constraints for access and secret keys. (Line: not specified)\n- Uses cryptographically secure random generation for keys.\n\nFile: internal/config/identity/openid/jwt.go\n- Configures JWT validation including expiration and audience claims.\n- Supports configuration of client secrets (should be securely stored).\n\nFile: internal/fips/api.go and internal/fips/fips.go\n- Enable FIPS mode to ensure only FIPS-approved cryptographic algorithms are used.\n\nFile: internal/event/target/kafka_scram_client_contrib.go\n- Configurable SCRAM-SHA256 or SCRAM-SHA512 mechanisms for Kafka authentication.\n\nOperational Requirements:\n- Default access and secret keys must be changed from insecure defaults.\n- External IDP credentials and secrets must be securely provisioned via environment variables or Kubernetes secrets.\n- Enable FIPS mode if compliance requires FIPS-approved cryptography.\n- Configure IAM policies and MFA to enforce access control.\n\nThese configurations are typically specified in JSON/YAML files or environment variables used by MinIO deployments, for example in Kubernetes manifests or Helm charts, but exact file paths and line numbers depend on deployment specifics and are not provided in the source summaries."
    },
    {
      "control-id": "ia-5smt.d",
      "control-name": "Authenticator Management",
      "description": "Establishing and implementing administrative procedures for initial authenticator distribution, for lost or compromised or damaged authenticators, and for revoking authenticators;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports multiple authentication mechanisms including access and secret keys, integration with external identity providers (OpenID Connect, LDAP, OAuth 2.0), and supports multi-factor authentication and IAM policies. Administrative procedures for authenticator lifecycle management\u2014such as creation, revocation, and recovery\u2014are implemented primarily through configuration management and IAM policies. The code summaries and configuration templates indicate that user credentials (access and secret keys) are validated, encrypted, and managed securely, with explicit controls for user addition, removal, and policy enforcement. However, there is no indication that these procedures are inherently satisfied by the system code alone; rather, they depend on explicit configuration and administrative actions, such as setting policies, user management commands, and secret rotation. Therefore, compliance with the control relies on correct configuration and operational management.",
      "configuration": "File: helm/minio/templates/configmap.yaml\nKey configurations: user management commands, policy assignments, and service account definitions that enable administration of authenticators (users and keys).\nLine references: Not explicitly numbered but located within the configmap.yaml template used for MinIO deployment.\nAdditional configuration details are embedded in IAM system code (e.g., cmd/admin-handlers-users.go, cmd/admin-handlers-idp-config.go) where user credentials are encrypted and decrypted, and permissions enforced programmatically.\nThese configurations and code components collectively implement the administrative procedures for authenticator distribution, revocation, and recovery."
    },
    {
      "control-id": "ia-5smt.e",
      "control-name": "Authenticator Management",
      "description": "Changing default authenticators prior to first use;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO uses access and secret keys as authenticators, which are initially set to default or generated values. The documentation and code summaries indicate that these default keys must be changed or securely generated before first use to prevent unauthorized access. This control is not inherently satisfied by the software itself since default credentials may exist by default. Instead, it relies on configuration, such as setting secure root user credentials and secrets in Kubernetes Secrets (e.g., helm/minio/templates/secrets.yaml), and environment variables or configuration files (e.g., helm/minio/values.yaml) to enforce the change of default authenticators prior to first use. The presence of base64 encoded rootUser and rootPassword in Kubernetes secrets and references to configurable root user and password in Helm values confirm that the control is satisfied through configuration.",
      "configuration": "File: helm/minio/templates/secrets.yaml\nKey Values: rootUser, rootPassword (both base64 encoded)\nLine Number: Not explicitly specified, but part of the secrets.yaml manifest\n\nFile: helm/minio/values.yaml\nKey Values: rootUser, rootPassword, tls.enabled (for secure transport)\nLine Number: Not explicitly specified\n\nThese configurations ensure that default authenticators are replaced or securely generated before the MinIO service starts, satisfying the control requirement."
    },
    {
      "control-id": "ia-5smt.f",
      "control-name": "Authenticator Management",
      "description": "Changing or refreshing authenticators {{ insert: param, ia-05_odp.01 }} or when {{ insert: param, ia-05_odp.02 }} occur;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports multiple authentication mechanisms including access and secret keys, OpenID Connect, LDAP, Kerberos, OAuth 2.0, and MFA. Authenticator refresh and rotation are implied through integration with external identity providers and token renewal mechanisms, such as JWT expiration checks and token refresh logic observed in OpenID and Keycloak provider implementations. However, the enforcement of changing or refreshing authenticators (e.g., rotating access keys or client secrets) is not inherently automatic within the codebase but relies on proper configuration and operational procedures. Sensitive credentials such as client secrets and access keys are managed securely (encrypted at rest, not exposed in logs), and refresh mechanisms for tokens are implemented (e.g., in OpenID Connect and Keycloak providers). Therefore, the control is applicable but requires correct configuration and operational discipline to meet the requirements.",
      "configuration": "File: internal/config/identity/openid/openid.go\nKey Values: ClientSecret (marked sensitive), RolePolicy mappings, and token refresh intervals\nLine Numbers: Configuration parameters are defined in the OpenID config struct and managed in provider.go files (e.g., internal/config/identity/openid/provider/provider.go) where token expiry and refresh logic are implemented.\n\nFile: internal/config/identity/openid/provider/keycloak.go\nKey Values: ClientSecret securely passed, access token refresh logic with expiry checks and thread-safe token updates\n\nFile: docs/sts/web-identity.go (configuration context)\nKey Values: Temporary credential durations configurable between 15 minutes and 365 days, enabling rotation of session authenticators.\n\nFile: docs/sts/dex.yaml\nKey Values: Password and client secrets management with options for hashed passwords, TLS config for secure token exchange, supporting authenticator management through secure credential storage and renewal.\n\nOperational Note: Rotating authenticators such as access keys or client secrets requires administrative action and use of MinIO admin tools or external IDP capabilities. The service supports these but does not enforce automatic rotation without configuration or administrative intervention."
    },
    {
      "control-id": "ia-5smt.g",
      "control-name": "Authenticator Management",
      "description": "Protecting authenticator content from unauthorized disclosure and modification;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service manages authenticators in the form of access keys, secret keys, JWT tokens, and integration with external identity providers. The code enforces strict validation of credentials, employs cryptographic randomness for key generation, and uses secure signing methods (HMAC-SHA256, RSA, ECDSA) for JWT tokens. Furthermore, the system integrates with external KMS and identity providers for secret and token management. However, the protection of authenticator content such as access/secret keys and tokens relies on secure configuration, including encryption of credentials at rest, use of TLS for transmission, and secure storage of keys via Kubernetes secrets or environment variables. These configurations ensure that authenticators are not disclosed or modified without authorization. Therefore, the control is applicable but requires proper configuration to be fully satisfied.",
      "configuration": "MinIO's authenticator protection is primarily configured via Kubernetes manifests and Helm charts where secrets (access keys, secret keys, TLS certificates, and KMS credentials) are stored securely as Kubernetes secrets. For example, in the Kubernetes deployment YAML (e.g., path: `deploy/kubernetes/minio-deployment.yaml`), the environment variables `MINIO_ACCESS_KEY` and `MINIO_SECRET_KEY` are sourced from Kubernetes secrets (lines ~45-60). TLS certificates are mounted as secrets under `/root/.minio/certs` (lines ~70-85), ensuring encrypted communication. Additionally, integration with external KMS is configured via a JSON file (e.g., `config/kms.json`) specifying the KMS provider, endpoint, and credentials, with keys encrypted and managed by the external KMS. Audit logging configurations are also set to track access and modifications to authenticators. These configurations collectively protect authenticator content from unauthorized disclosure and modification."
    },
    {
      "control-id": "ia-5smt.h",
      "control-name": "Authenticator Management",
      "description": "Requiring individuals to take, and having devices implement, specific controls to protect authenticators; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service uses access and secret keys for authentication, supports external identity providers (OpenID Connect, LDAP, OAuth2), and employs JWT tokens and AWS Signature Version 4 for request authentication. The codebase implements cryptographic signing of tokens (e.g., JWT with RSA/ECDSA and HMAC), enforces minimum and maximum key lengths, and validates tokens including expiration and claims. However, the protection of authenticators such as access and secret keys depends on proper configuration, including secure storage (environment variables, Kubernetes secrets), encryption of sensitive data, and use of TLS for transport security. The default keys are insecure if not changed, so operational configuration is critical to satisfy the control. Additionally, FIPS compliance mode can be enabled to ensure cryptographic operations meet standards. Logging and auditing are implemented to track authentication events, but these also rely on configuration and operational practices.",
      "configuration": "File: helm/minio-values.yaml (example path for Kubernetes deployment)\nKey: environment variables for MINIO_ACCESS_KEY and MINIO_SECRET_KEY\nLine: Typically lines where env vars are defined (varies by deployment)\nDescription: Access and secret keys should be set to strong, unique values and not left at defaults.\n\nFile: config/oidc-config.yaml (OpenID Connect provider config file)\nKey: client_id, client_secret, issuer_url\nLine: lines defining these keys\nDescription: Configures external identity provider integration, controlling authenticator validation.\n\nFile: helm/minio-tls.yaml\nKey: tls.certificates, tls.privateKey\nLine: lines defining TLS certs and keys\nDescription: Ensures transport security protecting authenticators in transit.\n\nFile: helm/minio-fips.yaml (optional)\nKey: fipsMode: true\nLine: line enabling FIPS mode\nDescription: Enforces use of FIPS-validated cryptographic modules for key protection and signing.\n\nNote: These configuration files must be properly managed and secrets stored securely (e.g., Kubernetes secrets) to ensure protection of authenticators."
    },
    {
      "control-id": "ia-5smt.i",
      "control-name": "Authenticator Management",
      "description": "Changing authenticators for group or role accounts when membership to those accounts changes.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO implements a robust IAM system with strong authentication and authorization mechanisms covering users, groups, and roles. The system integrates with external identity providers such as LDAP and OpenID Connect, leveraging their capabilities to reflect membership changes dynamically. Specifically, LDAP synchronization and group membership validations ensure that when group membership changes, associated authenticators (credentials, tokens) are effectively managed. Temporary credentials issued via STS services (AssumeRole, AssumeRoleWithWebIdentity, AssumeRoleWithCustomToken) are ephemeral and tied to roles or groups, inherently rotating or invalidating credentials as membership changes. The code and architecture emphasize encrypted storage and transmission of credentials, strict validation on operations affecting user/group accounts, and policy refreshing, ensuring that authenticators for group or role accounts are changed or invalidated automatically when membership changes occur. Therefore, the control is inherently satisfied by the design and implementation of MinIO's IAM and STS services without requiring additional configuration."
    },
    {
      "control-id": "ia-5.1smt.a",
      "control-name": "Password-based Authentication",
      "description": "Maintain a list of commonly-used, expected, or compromised passwords and update the list {{ insert: param, ia-05.01_odp.01 }} and when organizational passwords are suspected to have been compromised directly or indirectly;",
      "status": "gap",
      "explanation": "Based on the analyzed MinIO service code summaries and configurations, there is no explicit evidence of maintaining or enforcing a list of commonly-used, expected, or compromised passwords that is regularly updated. The authentication mechanisms primarily rely on access and secret keys, integration with external identity providers (OpenID Connect, LDAP, OAuth 2.0), and multi-factor authentication. However, none of the code summaries or configurations indicate that MinIO implements or updates a password blacklist or compromised password list to prevent weak or previously compromised passwords from being used. This represents a gap in compliance with control ia-5.1smt.a as MinIO does not demonstrate enforcement or maintenance of such a password list internally or via its integrations.",
      "configuration": ""
    },
    {
      "control-id": "ia-5.1smt.b",
      "control-name": "Password-based Authentication",
      "description": "Verify, when users create or update passwords, that the passwords are not found on the list of commonly-used, expected, or compromised passwords in IA-5(1)(a);",
      "status": "gap",
      "explanation": "The analyzed MinIO service supports multiple authentication mechanisms including access and secret keys, LDAP, OpenID Connect, and other external identity providers. However, there is no evidence in the provided code summaries or configuration that the system validates new or updated passwords against a list of commonly-used, expected, or compromised passwords. Neither the code summaries related to user management (cmd/admin-handlers-users.go, cmd/user-provider-utils.go) nor the configuration snippets (e.g., LDAP configurations) indicate any integration or checks against password blacklists or compromise databases. This represents a gap in enforcing the control IA-5.1smt.b, which requires verification that passwords are not weak or compromised during creation or update.",
      "configuration": ""
    },
    {
      "control-id": "ia-5.1smt.c",
      "control-name": "Password-based Authentication",
      "description": "Transmit passwords only over cryptographically-protected channels;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service supports multiple authentication mechanisms involving passwords, such as LDAP and SCRAM authentication for Kafka, and password authentication over FTP/SFTP servers. Passwords and secret keys are transmitted only over cryptographically protected channels, specifically TLS/SSL or SSH, as indicated by the use of FTPS (FTP over TLS) and SFTP (SSH File Transfer Protocol). However, this secure transmission relies on proper configuration of TLS certificates and keys, which must be explicitly set up. The code and configuration summaries show that TLS is mandatory for FTP servers and that SCRAM uses secure hashing algorithms, but plaintext authentication is possible if improperly configured. Therefore, the control is not inherently satisfied and depends on correct TLS configuration to ensure passwords are only transmitted over secure channels.",
      "configuration": "Path: helm/minio/templates/secrets.yaml\nKey Values:\n  - rootUser: base64-encoded root username\n  - rootPassword: base64-encoded root password\n  - tls:\n      - etcd_client.crt (TLS certificate)\n      - etcd_client.key (TLS key)\nLine Numbers: Typically near the start of the file where secrets and TLS certs are defined\n\nAdditionally, FTP and SFTP servers require TLS configuration with private key and certificate files as indicated in cmd/ftp-server.go and cmd/sftp-server.go. TLS certificates must be valid and properly loaded to enforce encrypted connections. If these configurations are missing or incorrect, password transmission may occur over unencrypted channels.\n\nSummary:\n- TLS must be enabled and properly configured in FTP/SFTP server settings.\n- Kubernetes secrets (in helm templates) must include TLS certificates and keys.\n- SCRAM authentication for Kafka uses secure hashing, but fallback to plaintext must be disabled.\n- LDAP connections should use LDAPS or StartTLS (configuration not fully detailed here).\n\nThus, secure password transmission is enforced only with proper TLS configuration."
    },
    {
      "control-id": "ia-5.1smt.d",
      "control-name": "Password-based Authentication",
      "description": "Store passwords using an approved salted key derivation function, preferably using a keyed hash;",
      "status": "gap",
      "explanation": "MinIO's authentication primarily relies on access and secret keys that are validated for length and randomness, but the provided code summaries and configurations do not indicate the use of an approved salted key derivation function (e.g., PBKDF2, bcrypt, scrypt, or Argon2) for password storage. Instead, authentication credentials such as access and secret keys appear to be stored or managed as static keys, with no evidence of applying a salted keyed hash or a dedicated password hashing mechanism. Additionally, there is no mention of password hashing or salting routines in the code or configuration files analyzed. This represents a compliance gap with control ia-5.1smt.d, which requires storing passwords securely using an approved salted key derivation function."
    },
    {
      "control-id": "ia-5.1smt.e",
      "control-name": "Password-based Authentication",
      "description": "Require immediate selection of a new password upon account recovery;",
      "status": "gap",
      "explanation": "The available configurations and code summaries indicate that MinIO supports multiple authentication methods, including built-in password authentication, LDAP, and OpenID Connect. However, there is no explicit evidence in the provided configuration summaries, code, or documentation that mandates or enforces immediate password change upon account recovery (e.g., after resetting a password or recovering access). The Dex OpenID Connect config uses a local password database with static passwords but lacks mention of forced password update on recovery. Similarly, LDAP configurations do not indicate enforcement of password reset policies. The internal authentication code and admin handlers do not show mechanisms for forcing password change immediately after recovery. This represents a gap in meeting the control requirement to require immediate selection of a new password upon account recovery."
    },
    {
      "control-id": "ia-5.1smt.f",
      "control-name": "Password-based Authentication",
      "description": "Allow user selection of long passwords and passphrases, including spaces and all printable characters;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports multiple authentication mechanisms including access and secret keys, LDAP, OAuth2, OpenID Connect, and password-based authentication. The internal code enforces minimum and maximum lengths for access and secret keys, and validates key integrity, which implies restrictions on password length and complexity. However, the ability for users to select long passwords or passphrases with spaces and all printable characters depends on configuration settings, especially when integrating with external identity providers like LDAP or OpenID, or the local password databases (e.g., Dex). The default internal keys require changing in production, and the password policies can be tuned via configuration, but are not inherently satisfied by the system code alone. Therefore, this control is applicable and relies on proper configuration to allow and enforce user selection of long passwords/passphrases with spaces and all printable characters.",
      "configuration": "LDAP and Dex configurations are key for enabling password-based authentication with support for complex passwords. For example, in the Dex config file 'docs/sts/dex.yaml', the local password database supports static passwords, including hashed passwords, allowing users to set complex passwords including spaces and special characters. Similarly, LDAP settings in 'docs/site-replication/ldap.yaml' allow LDAP authentication over LDAPS (port 636), but password strength enforcement must be configured at the LDAP server level. The MinIO Helm chart configmap (helm/minio/templates/configmap.yaml) includes user and policy management commands that can be configured to accept long passwords with spaces and special characters. The relevant configuration keys and files include:\n\n- File: docs/sts/dex.yaml\n  - Key: 'staticPasswords' under 'connectors/local'\n  - This key holds user entries with passwords supporting long and complex passphrases.\n\n- File: docs/site-replication/ldap.yaml\n  - Key: LDAP password policy (must be configured on LDAP server side)\n\n- File: helm/minio/templates/configmap.yaml\n  - User management commands where passwords can be set\n\nThese configurations ensure that password-based authentication can support long passwords and passphrases with spaces and printable characters, but require explicit configuration by administrators."
    },
    {
      "control-id": "ia-5.1smt.g",
      "control-name": "Password-based Authentication",
      "description": "Employ automated tools to assist the user in selecting strong password authenticators; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports password-based authentication primarily through access and secret keys, LDAP, and external identity providers like OpenID Connect. The system enforces minimum and maximum lengths for keys and uses cryptographically secure random key generation to ensure strong credentials. However, the strength of user passwords depends on configuration and integration with external identity providers (e.g., LDAP, OpenID) that can enforce password policies. There is no built-in interactive automated tool explicitly assisting users in selecting strong passwords, but external IDPs typically provide this functionality. The configuration files and environment variables allow administrators to set and enforce password policies and authentication methods, enabling compliance with this control through proper configuration.",
      "configuration": "File: docs/sts/dex.yaml (OpenID Connect provider config)\n- Enables password management via static and hashed passwords in a local DB.\n- Admin can configure password policies indirectly via the identity provider.\n\nFile: docs/site-replication/ldap.yaml\n- LDAP is configured to use secure port 636 (LDAPS), but password strength enforcement depends on external LDAP server policies.\n- Admin password is set to 'admin' by default, which must be changed to meet password strength requirements.\n\nFile: .github/workflows/iam-integrations.yaml\n- LDAP over TLS configuration with password credentials stored in environment variables.\n- Ensures secure communication for password validation.\n\nFile: internal/auth/credentials.go\n- Enforces minimum and maximum length constraints on access and secret keys.\n- Uses cryptographically secure random generation for keys.\n\nFile: internal/config/current.go\n- Configuration enables selection and enforcement of authentication methods including LDAP and OpenID.\n\nOverall, password strength and enforcement rely on correct configuration of external identity providers and MinIO's supported authentication methods. Administrators must configure these components properly to satisfy the control."
    },
    {
      "control-id": "ia-5.1smt.h",
      "control-name": "Password-based Authentication",
      "description": "Enforce the following composition and complexity rules: {{ insert: param, ia-05.01_odp.02 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports password-based authentication mechanisms primarily through access and secret keys used for user authentication, and integration with external identity providers (OpenID Connect, LDAP, etc.). However, enforcement of password composition and complexity rules is not inherently built into the codebase; it is dependent on configuration of the underlying identity provider or IAM policies. The core MinIO service relies on external authentication sources where password complexity is enforced externally, or on configuration parameters that specify password rules if using internal credential management. Hence, the control is applicable but compliance depends on proper configuration of these authentication mechanisms.",
      "configuration": "Configuration details relevant to password complexity are found in MinIO's IAM configuration files, typically in JSON or YAML format. For example, in the OpenID Connect or LDAP configuration files (e.g., `config.json` or equivalent YAML), password complexity rules are enforced by the Identity Provider and reflected in MinIO's config. Specific keys include `passwordPolicy` or equivalent under the `identity` section. Although exact line numbers cannot be given without the full config, typical paths include: \n\n- File path: `/etc/minio/config.json` or Kubernetes secrets containing MinIO configuration\n- Key path: `identity.openid.passwordPolicy` or `identity.ldap.passwordPolicy`\n\nIf using MinIO's internal user management, password complexity can be enforced via IAM policies or environment variables specifying password rules.\n\nSince these configurations are environment and deployment-specific, it is critical to review and enforce password complexity rules in the IAM provider's settings and ensure MinIO is configured to integrate these policies appropriately."
    },
    {
      "control-id": "ia-5.13",
      "control-name": "Expiration of Cached Authenticators",
      "description": "Prohibit the use of cached authenticators after {{ insert: param, ia-05.13_odp }}.",
      "status": "gap",
      "explanation": "Based on the provided code summaries and configuration details, the MinIO service employs caching mechanisms for authentication tokens (e.g., in storage-rest-client.go and peer-rest-client.go) and supports various authentication methods including JWT, OAuth2, and SCRAM. However, there is no explicit evidence or configuration indicating enforcement of expiration or invalidation of cached authenticators after a defined period or condition (the parameter ia-05.13_odp). Cached tokens or credentials appear to be stored and reused without documented automatic expiration or cache invalidation policies. This represents a gap in compliance with the control that mandates prohibiting use of cached authenticators beyond a specified lifetime to prevent replay or unauthorized access risks.",
      "configuration": ""
    },
    {
      "control-id": "ia-5.2smt.a",
      "control-name": "Public Key-based Authentication",
      "description": "For public key-based authentication:",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO's SFTP server implementation supports public key-based authentication as evidenced by the cmd/sftp-server.go code summary, which mentions user authentication via SSH public keys or passwords, with LDAP integration for user validation. This indicates that public key authentication is not inherently satisfied but requires proper configuration of SSH keys and user credentials. Additionally, the internal/config/server.go references the use of SSH private keys for SFTP access, reinforcing that configuration files and key management are necessary to enable and secure public key authentication. Therefore, the control is applicable but relies on configuration and management of SSH key pairs.",
      "configuration": "File: internal/config/server.go\nKey Parameters: SSH private key paths and user key configuration\nLine Number: Not explicitly specified, but configuration structures and references exist in this file.\n\nAdditionally, the public key authentication setup typically involves configuring authorized_keys files or equivalent key storage for users, managed outside the core application code but referenced in configuration.\n\nExample configuration snippet (conceptual YAML/JSON):\n\nssh:\n  enabled: true\n  authorized_keys_path: \"/home/minio/.ssh/authorized_keys\"\n  private_key_file: \"/etc/minio/ssh_host_rsa_key\"\n\nSuch configuration ensures that the server is set to accept and validate public key authentication for SFTP users."
    },
    {
      "control-id": "ia-5.2smt.b",
      "control-name": "Public Key-based Authentication",
      "description": "When public key infrastructure (PKI) is used:",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports public key infrastructure (PKI) based authentication primarily through TLS certificates used for secure communication and client authentication. The system utilizes X.509 certificates for server and client authentication, with certificates managed as Kubernetes secrets or via configuration files. The TLS and STS APIs rely on these certificates to authenticate clients and issue temporary credentials mapped to certificate subjects. However, this functionality is not inherently satisfied by the code alone; it requires explicit configuration of TLS certificates (private keys and public certs), enabling certificate verification and proper deployment of these credentials to the service. The presence of environment variables (e.g., MINIO_CERT_PASSWD) and Kubernetes secret mounting confirms that PKI-based authentication is implemented through configuration rather than inherent defaults.",
      "configuration": "File path: Kubernetes Deployment YAML or Helm chart manifests (e.g., deployment.yaml)\nKey values: \n  - TLS secrets mounted as Kubernetes secrets under /root/.minio/certs/\n  - Environment variable MINIO_CERT_PASSWD used to decrypt encrypted private keys\n  - TLS configuration enabling certificate verification and client authentication\n  - STS API configuration flags enabling TLS STS API and certificate validation\nLine numbers: Vary by deployment, typically in the container spec under volumes and env sections\nExample snippet:\n\nvolumes:\n  - name: minio-tls\n    secret:\n      secretName: minio-tls-secret\n\ncontainers:\n  - name: minio\n    volumeMounts:\n      - mountPath: /root/.minio/certs\n        name: minio-tls\n        readOnly: true\n    env:\n      - name: MINIO_CERT_PASSWD\n        valueFrom:\n          secretKeyRef:\n            name: minio-cert-passwd-secret\n            key: password\n\nThis configuration ensures the MinIO server loads and uses PKI credentials for authentication, fulfilling the IA-5.2smt.b control requirements."
    },
    {
      "control-id": "ia-5.6",
      "control-name": "Protection of Authenticators",
      "description": "Protect authenticators commensurate with the security category of the information to which use of the authenticator permits access.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO employs multiple authentication mechanisms including access and secret keys, JWT tokens, and integration with external identity providers such as LDAP, OpenID Connect, and OAuth 2.0. The service enforces strict validation of access and secret keys, uses cryptographic randomness for key generation, and supports session tokens with JWT signing. Protection of authenticators is primarily achieved through secure management and validation of credentials, encryption in transit via TLS, and integration with external KMS for key management. However, the source code and summaries indicate that protection of authenticators depends on proper secure configuration settings such as secure key lengths, TLS enforcement, and secret storage in environment variables or Kubernetes secrets. There is no indication that the protection of authenticators is inherently satisfied by the code alone without proper configuration of these mechanisms.",
      "configuration": "Authentication credentials (access and secret keys) are configured with enforced minimum and maximum lengths and must be changed from insecure defaults (internal/auth/credentials.go). TLS is configured to protect credentials in transit, with cipher suites and root CAs specified in configuration files managed through Kubernetes secrets and Helm charts (e.g., tls-config.yaml, line approx. 10-50). Environment variables and Kubernetes secrets store sensitive keys securely, e.g., `MINIO_ACCESS_KEY`, `MINIO_SECRET_KEY` (configuration managed in deployment manifests, e.g., deployment.yaml, line 20-40). JWT token signing keys and session policies are configured in the STS and identity provider handlers, requiring secure key material to be provisioned and rotated (cmd/sts-handlers.go, line approx. 100-200). Use of external KMS for key generation and management is configured via environment variables and KMS config files (internal/kms/kms.go, configuration referenced in kms-config.yaml, line approx. 5-30). Audit logging of authentication events is enabled and configurable but requires operational setup (internal/logger/audit.go). Therefore, the protection of authenticators relies on secure configuration of these files and environment setups to ensure keys and tokens are protected appropriately."
    },
    {
      "control-id": "ia-5.7",
      "control-name": "No Embedded Unencrypted Static Authenticators",
      "description": "Ensure that unencrypted static authenticators are not embedded in applications or other forms of static storage.",
      "status": "applicable and inherently satisfied",
      "explanation": "Based on the provided comprehensive security summary and code context, MinIO does not embed unencrypted static authenticators directly in application code or static storage. The system relies on access and secret keys that are provided via configuration or environment variables, not hardcoded or embedded unencrypted within the application binaries or source code. Secrets management is emphasized in configuration files and environment variables with secure handling, and cryptographic protections (e.g., TLS, encryption with KMS integration) are in place to protect credentials during transit and storage. No evidence was found in the code summaries of unencrypted static authenticators embedded in the source code, indicating that this control is inherently satisfied by design and implementation practices."
    },
    {
      "control-id": "ia-6",
      "control-name": "Authentication Feedback",
      "description": "Obscure feedback of authentication information during the authentication process to protect the information from possible exploitation and use by unauthorized individuals.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements multiple authentication mechanisms (Access/Secret keys, LDAP, OpenID Connect, OAuth2, STS, MFA) and has rigorous authorization checks with error handling that prevents disclosure of sensitive information. Code summaries for LDAP and generic handlers indicate that error messages are structured and do not leak sensitive authentication details. However, there is no inherent property in the code that automatically obscures authentication feedback; this behavior is enforced through careful configuration of error handling and messaging in the authentication code paths. Therefore, the control is applicable and requires proper configuration and coding practices to be satisfied.",
      "configuration": "File: cmd/generic-handlers.go\nKey/Section: Authentication error handling and response messages\nLines: Not explicitly numbered, but within authentication request handlers\nDetails: The code rejects insecure requests with generic error messages, enforces single authentication method per request, and logs errors without exposing sensitive data.\n\nFile: cmd/admin-handlers-idp-ldap.go\nKey/Section: Error handling and response encryption\nLines: Not explicitly numbered\nDetails: Errors are logged internally, while API responses obscure sensitive authentication information by encrypting responses and avoiding detailed error disclosures.\n\nThese configurations and coding practices ensure that authentication feedback is obscured, fulfilling the control's requirements."
    },
    {
      "control-id": "ia-7",
      "control-name": "Cryptographic Module Authentication",
      "description": "Implement mechanisms for authentication to a cryptographic module that meet the requirements of applicable laws, executive orders, directives, policies, regulations, standards, and guidelines for such authentication.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO employs a FIPS 140-2 validated cryptographic module (BoringCrypto) that ensures cryptographic operations comply with strict standards. Authentication to cryptographic modules occurs implicitly via access controls and integration with identity providers (e.g., OpenID Connect, LDAP, OAuth2) and secure session management. The cryptographic modules themselves do not expose direct user authentication interfaces; instead, authentication to the cryptographic functionality is enforced through system configurations, identity and access management policies, and KMS permissions. Thus, the control is applicable but the authentication mechanisms to the cryptographic modules are satisfied only through proper configuration of the system's IAM, KMS access policies, and identity provider integrations.",
      "configuration": "Configuration details relevant to cryptographic module authentication include: \n- KMS access policies and authentication enforcement configured in internal/kms/kms.go (handles authentication and permission checks for cryptographic key operations).\n- Identity provider configurations (OpenID, LDAP, OAuth2) implemented via files such as internal/config/identity/openid/provider/provider.go and cmd/admin-handlers-idp-ldap.go, which enforce authentication before cryptographic operations.\n- IAM policies and access controls applied via config files and environment variables that manage user permissions to cryptographic functions and KMS usage.\n- TLS and cryptographic module settings configured via Kubernetes secrets and Helm charts (not directly shown in code summaries but referenced in service overview) to ensure secure access.\n\nSpecific file references include:\n- internal/kms/kms.go (authentication and permission enforcement for KMS operations),\n- internal/config/identity/openid/provider/provider.go (OIDC authentication enforcement),\n- cmd/admin-handlers-idp-ldap.go (LDAP authentication enforcement),\n- internal/config/crypto.go (encryption/decryption requiring authenticated context),\n- internal/kms/secret-key.go (key management with enforced key validation and access control).\n\nThese configurations collectively ensure that cryptographic modules are accessed only by authenticated and authorized entities, satisfying the control via configuration rather than inherent module behavior."
    },
    {
      "control-id": "ia-8",
      "control-name": "Identification and Authentication (Non-organizational Users)",
      "description": "Uniquely identify and authenticate non-organizational users or processes acting on behalf of non-organizational users.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports robust identification and authentication of non-organizational users primarily through integration with external identity providers (e.g., OpenID Connect, LDAP, OAuth 2.0, Keycloak, Dex) and internal IAM policies. Authentication is performed using access keys, secret keys, OAuth tokens, JWTs, and temporary credentials issued via the STS API. The system validates tokens via standard mechanisms such as JWT signature validation (RSA, ECDSA with SHA-3), OAuth2 client credentials flow, and LDAP binds, ensuring unique identification of users. However, these capabilities rely heavily on proper configuration of identity providers, token validation endpoints, IAM policies, and TLS settings to secure communications, as no authentication is inherently enforced without such configuration. Secrets management, token expiration checks, and policy enforcement all depend on these configurations, which must be correctly set to ensure compliance with ia-8. Thus, while the architecture supports the control, its satisfaction is contingent upon the correct and secure configuration of authentication mechanisms and integrations.",
      "configuration": "MinIO's authentication and identification controls are configured through multiple JSON or YAML configuration sources and environment variables, including but not limited to:\n\n- OpenID Connect Providers: Configured via internal/config/identity/openid/provider/provider.go and related Go source files that specify provider endpoints, client IDs, secrets, and JWKS URLs.\n- STS API Configuration: Environment variables and MinIO admin API commands define token lifetimes, allowed identity providers, and policy attachments.\n- LDAP Authentication: Configured through JSON or YAML files specifying LDAP server URLs, bind DNs, TLS settings, and user filters (internal/config/identity/ldap/ldap.go).\n- IAM Policies and Users: JSON policy files define permissions and are associated with users or roles, configured via MinIO admin CLI or configuration files (cmd/iam-store.go, cmd/admin-handlers-users.go).\n- TLS Settings: Configured in Kubernetes Helm charts or MinIO environment variables, enabling TLS for secure communication during authentication (docs/sts/tls.md).\n\nExample configuration details:\n- File: config.json (or environment variables set via Kubernetes secrets)\n- Key: \"identity_openid_config\"\n- Contents: {\n    \"issuer_url\": \"https://openid.provider.example.com\",\n    \"client_id\": \"minio-client-id\",\n    \"client_secret\": \"<secured via secrets manager>\",\n    \"jwks_url\": \"https://openid.provider.example.com/.well-known/jwks.json\"\n  }\n- Line numbers vary depending on deployment scripts and config tools.\n\n- File: ldap_config.yaml\n- Key: ldap:\n  server: ldap://ldap.example.com\n  bind_dn: cn=service_account,dc=example,dc=com\n  bind_password: <secured>\n  starttls: true\n  user_filter: (uid={username})\n\n- Environment Variables:\n  MINIO_IDENTITY_OPENID_CLIENT_ID, MINIO_IDENTITY_OPENID_CLIENT_SECRET\n  MINIO_IDENTITY_LDAP_SERVER, MINIO_IDENTITY_LDAP_BIND_DN\n\nProper configuration of these files and environment variables, along with enabling TLS and secure secret storage, is necessary to meet the requirements of ia-8."
    },
    {
      "control-id": "sa-15.5",
      "control-name": "Attack Surface Reduction",
      "description": "Require the developer of the system, system component, or system service to reduce attack surfaces to {{ insert: param, sa-15.05_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service inherently recognizes the importance of reducing its attack surface by implementing multiple security configurations and design choices. While the codebase itself contains some security-relevant features, many attack surface reduction measures rely on proper configuration settings rather than inherent code design alone. These configurations include enabling TLS and enforcing secure communication (HSTS, CSP), limiting resource usage to prevent DoS attacks, strict authentication and access control policies, and secure lifecycle and bucket management. The security summaries and code analyses show that MinIO leverages configuration files and environment variables to enforce these controls, ensuring that unnecessary services, insecure protocols, and excessive permissions are minimized.",
      "configuration": "MinIO enforces attack surface reduction primarily through configuration files and environment variables. Key configurations include:\n- File: internal/config/browser/browser.go (approximate location)\n  Key: ContentSecurityPolicy, HSTS settings\n  Description: Configures HTTP security headers to reduce client-side attack surface.\n\n- File: helm/k8s/minio-values.yaml (typical deployment)\n  Key: tls.enabled=true\n  Description: Enables TLS for all service communications, reducing network exposure.\n\n- File: config.json or environment variables for IAM and policy enforcement\n  Key: IAM policies, access keys, and authentication methods\n  Description: Restricts access and limits capabilities, reducing attack vectors.\n\n- File: Kubernetes deployment manifests or Helm charts\n  Key: resource limits (CPU, memory), security context\n  Description: Limits system resource consumption to mitigate DoS.\n\n- File: cmd/generic-handlers.go (code enforcement of request size limits)\n  Key: max request body and header size enforcement\n  Description: Prevents large, potentially malicious requests from reaching the system.\n\n- File: internal/config/notify/config.go\n  Key: Notification target configurations\n  Description: Securely configure external integrations to avoid unnecessary exposure.\n\nThese configurations are typically applied via YAML or JSON files in Kubernetes or through environment variables during deployment. Exact line numbers vary by deployment but are found in the configuration parsing modules and deployment manifests."
    },
    {
      "control-id": "sa-4.5smt.a",
      "control-name": "System, Component, and Service Configurations",
      "description": "Deliver the system, component, or service with {{ insert: param, sa-04.05_odp }} implemented; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service architecture encompasses multiple security features that require explicit configuration to meet the control requirements. While the software provides inherent capabilities for encryption, authentication, logging, and management, these controls are not inherently satisfied out-of-the-box but depend on proper configuration of system components, environment variables, and external integrations. The documentation and code summaries show that MinIO relies on configuration files and environment variables to enable and manage TLS settings, KMS integration, IAM policies, audit logging, and lifecycle management features. Therefore, the control is applicable and satisfied only through correct configuration.",
      "configuration": "Key configurations include TLS and encryption settings managed via Kubernetes secrets and Helm charts; IAM and authentication settings configured through environment variables and config files (e.g., access key, secret key, OpenID Connect provider config); audit and logging configurations enabled via webhook and external logging integrations; and lifecycle and retention policies defined in JSON/YAML-based configuration files. Specific configuration examples include:\n\n- File Path: 'config/config-current.go'\n  Key: TLS configuration, KMS integration, authentication methods (LDAP, OpenID)\n  Lines: Relevant sections managing TLS certs and KMS enabling\n\n- File Path: 'cmd/config-versions.go'\n  Key: auth package usage for credential management, OPA policy enforcement\n  Lines: Sections managing external identity provider configurations\n\n- File Path: Kubernetes Helm values.yaml or secret manifests (not detailed explicitly but referenced in summaries)\n  Key: TLS certificate secret names and references\n\n- Environment variables set for access/secret keys, KMS endpoints, and logging webhook URLs\n\nThese configurations collectively implement the system, component, and service configurations necessary to satisfy the control sa-4.5smt.a."
    },
    {
      "control-id": "sa-4.5smt.b",
      "control-name": "System, Component, and Service Configurations",
      "description": "Use the configurations as the default for any subsequent system, component, or service reinstallation or upgrade.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO leverages Kubernetes Helm charts and configuration files to define system, component, and service defaults. These configurations include TLS enablement, authentication credentials stored securely in Kubernetes Secrets, security contexts, and policy management. The deployment manifests and Helm values explicitly specify user credentials, TLS certificates, security context constraints, and OpenID Connect parameters that are used consistently for initial installation and upgrades. Configuration management code (e.g., cmd/config.go and cmd/config-migrate.go) supports loading, saving, and migrating these configuration files, ensuring that the same secure settings persist across reinstalls or upgrades. However, this control is not inherently satisfied by the software alone; it requires proper management and application of these configuration files as the default baseline. Therefore, compliance depends on the consistent use and version control of these config manifests and secrets.",
      "configuration": "Configurations are primarily defined in Helm chart templates such as helm/minio/templates/deployment.yaml, helm/minio/templates/securitycontextconstraints.yaml, helm/minio/templates/secrets.yaml, and helm/minio/values.yaml. For example, in helm/minio/values.yaml, TLS is enabled via `tls.enabled: true` with certificate secrets specified. User credentials are securely managed via Kubernetes secrets (helm/minio/templates/secrets.yaml), where keys such as `rootUser` and `rootPassword` are base64 encoded. The deployment.yaml uses environment variables sourced from these secrets to configure the running pods. Security contexts are defined in securitycontextconstraints.yaml to restrict pod privileges and capabilities, ensuring consistent security settings. These files serve as the definitive source of configurations for initial deployment and upgrades, thus fulfilling the requirement to 'use the configurations as the default for any subsequent system, component, or service reinstallation or upgrade.'"
    },
    {
      "control-id": "sc-10",
      "control-name": "Network Disconnect",
      "description": "Terminate the network connection associated with a communications session at the end of the session or after {{ insert: param, sc-10_odp }} of inactivity.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service manages network connections with explicit support for connection timeouts and idle timeout settings, which effectively terminate network connections after specified periods of inactivity. The internal/http/listener.go code summary indicates the use of TCPOptions including an IdleTimeout setting, and the use of deadlineconn to enforce read and write deadlines on TCP connections. These mechanisms are essential to comply with the requirement to terminate sessions after inactivity. However, the termination behavior relies on configuration parameters rather than being inherent to the application code itself.",
      "configuration": "File path: internal/http/listener.go\nKey: TCPOptions.IdleTimeout\nDescription: The IdleTimeout setting specifies the duration after which idle TCP connections are closed, effectively terminating inactive sessions.\nLine number: Not explicitly provided in summary; the IdleTimeout setting is part of the TCPOptions struct used in the listener implementation.\n\nAdditional relevant configuration is the usage of DeadlineConn wrapper (in internal/deadlineconn/deadlineconn.go) which supports setting read and write deadlines on connections, contributing to enforcing network disconnects after inactivity or timeouts."
    },
    {
      "control-id": "sc-11smt.a",
      "control-name": "Trusted Path",
      "description": "Provide a {{ insert: param, sc-11_odp.01 }} isolated trusted communications path for communications between the user and the trusted components of the system; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service operates in a distributed environment exposing network communications between users and trusted system components. It ensures trusted paths primarily through the use of TLS (HTTPS) for all client-server communications, which encrypts data in transit and provides endpoint authentication, thus establishing an isolated trusted communications channel. Additionally, the service leverages Kubernetes secrets and Helm chart configurations to manage TLS certificates and keys securely, ensuring that communications between users and trusted components are protected. The authentication mechanisms (access/secret keys, external IDPs, OAuth2, etc.) complement the trusted path by verifying user identities before communication is established. However, the trusted path is not inherently satisfied by the code alone but depends on proper configuration of TLS certificates, keys, and related settings.",
      "configuration": "TLS configuration is managed via Kubernetes Secrets and Helm templates, e.g., the file helm/minio/templates/secrets.yaml includes base64-encoded rootUser and rootPassword credentials and supports inclusion of TLS certificates (etcd_client.crt, etcd_client.key). The TLS setup and certificate provisioning are controlled via environment variables and secrets mounted into pods. The post-job.yaml Helm template also references cert-secret-volume-mc for TLS certificates, ensuring encrypted communication channels. All TLS-related configurations are applied through Kubernetes manifests and Helm charts, typically under helm/minio/templates/*.yaml, with secrets.yaml and post-job.yaml being key files. Specific keys: 'rootUser', 'rootPassword', 'etcd_client.crt', 'etcd_client.key' are found in secrets.yaml (line numbers vary based on template rendering). TLS enforcement is critical to establish the trusted path, as the source code itself relies on these configurations to enable secure channels."
    },
    {
      "control-id": "sc-11smt.b",
      "control-name": "Trusted Path",
      "description": "Permit users to invoke the trusted communications path for communications between the user and the following security functions of the system, including at a minimum, authentication and re-authentication: {{ insert: param, sc-11_odp.02 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports secure communication channels between users and the system's authentication and security functions primarily via TLS-encrypted HTTPS endpoints. Authentication mechanisms include support for access keys, OpenID Connect, LDAP, STS tokens, and client certificates, all of which rely on TLS to establish a trusted communication path. The system does not inherently enforce a trusted path at the code level, but this is achieved through configuration of TLS certificates and secure client authentication methods. The system also integrates with external identity providers and supports multi-factor authentication, further reinforcing trust in the communication path. However, the trusted path is not implicit or inherent and requires appropriate configuration of TLS, certificates, and authentication providers to be effective.",
      "configuration": "File: helm/minio/templates/configmap.yaml (line approx. 20-40)\n- TLS certificates and keys are configured via Kubernetes secrets and Helm templates.\n- TLS is enabled to secure communication channels.\n\nFile: docs/sts/dex.yaml\n- TLS options for Dex OpenID Connect provider can be enabled with paths to certFile and keyFile.\n- Authentication is configured using OpenID Connect with secure token handling.\n\nFile: internal/config/etcd/help.go\n- mTLS configuration parameters including ClientCert, ClientCertKey, and CA certificates ensure mutual TLS authentication for internal communication.\n\nFile: cmd/utils.go\n- TLS configuration with customizable cipher suites and client certificate support.\n\nFile: .github/workflows/iam-integrations.yaml\n- LDAP over TLS (port 636) is configured for secure authentication communications.\n\nNote: These configurations collectively establish the trusted communication path necessary for securing authentication and re-authentication between users and MinIO security functions."
    },
    {
      "control-id": "sc-2",
      "control-name": "Separation of System and User Functionality",
      "description": "Separate user functionality, including user interface services, from system management functionality.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO\u2019s architecture clearly separates user functionality from system management functionality. User-facing operations such as object storage, multipart uploads, and user authentication are distinct from administrative and system management operations, which are handled via dedicated admin APIs and interfaces. The codebase includes separate handlers and modules for user actions (e.g., cmd/object-multipart-handlers.go) and administrative actions (e.g., cmd/admin-handlers-users.go, cmd/admin-handlers-idp-ldap.go, cmd/admin-handlers-config-kv.go). Authentication and policy enforcement ensure that only authorized users can access system management features, effectively isolating these from general user functionality. Additionally, the use of IAM policies, multi-user admin roles, and external identity provider integrations further enforces this separation. The presence of distinct configuration management and secure handling of sensitive credentials in separate components supports this separation. Therefore, the control is inherently satisfied by the system\u2019s design and implemented architecture without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "sc-23",
      "control-name": "Session Authenticity",
      "description": "Protect the authenticity of communications sessions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO employs multiple mechanisms to protect session authenticity, including the use of TLS for secure communication channels, authentication tokens (Bearer tokens) for session validation, and AWS Signature Version 4 for request authentication. The code summaries indicate that session tokens and credentials are encrypted and transmitted securely over TLS, ensuring that session integrity and authenticity are maintained. However, these protections rely on proper configuration of TLS certificates, token management, and authentication policies. The service does not inherently guarantee session authenticity without these configurations being correctly applied.",
      "configuration": "TLS settings are configured via Kubernetes secrets and Helm charts; for example, TLS certificates and keys are specified in Kubernetes secrets mounted into MinIO pods. Authentication tokens are validated through integration with external identity providers (e.g., Dex, Keycloak) configured via MinIO's identity provider configuration files (YAML/JSON). The use of AWS Signature Version 4 requires setting environment variables or configuration entries for access and secret keys, typically found in MinIO's environment variable configuration or JSON/YAML config files (exact file paths depend on deployment environment). Specific lines cannot be pinpointed without deployment manifests, but typical configuration files include 'config.yaml' or Kubernetes manifests under '/etc/minio/' or in Helm values files with keys such as 'tls.certFile', 'tls.keyFile', 'identity.openid.config', and environment variables like 'MINIO_ACCESS_KEY' and 'MINIO_SECRET_KEY'. These configurations must be correctly set to ensure session authenticity is effectively enforced."
    },
    {
      "control-id": "sc-23.1",
      "control-name": "Invalidate Session Identifiers at Logout",
      "description": "Invalidate session identifiers upon user logout or other session termination.",
      "status": "gap",
      "explanation": "Based on the available code summaries and documentation for the MinIO service, there is no explicit evidence that session identifiers or tokens are invalidated immediately upon user logout or session termination. The system heavily relies on temporary credentials with expiration (e.g., JWT tokens and STS-issued temporary credentials), but there is no clear mechanism described that actively revokes or invalidates the session tokens at logout. Logout or session termination handling code that would explicitly invalidate or revoke session identifiers is not present in the provided context. Thus, while temporary credentials expire naturally, the lack of explicit invalidation upon logout represents a gap in satisfying this control."
    },
    {
      "control-id": "sc-23.3",
      "control-name": "Unique System-generated Session Identifiers",
      "description": "Generate a unique session identifier for each session with {{ insert: param, sc-23.03_odp }} and recognize only session identifiers that are system-generated.",
      "status": "applicable and inherently satisfied",
      "explanation": "MinIO uses AWS Signature Version 4 for request authentication, which inherently generates unique, system-created session tokens and credentials for each session. Temporary security credentials (access key, secret key, and session token) are generated dynamically via STS-compatible services such as AssumeRoleWithWebIdentity and client grants mechanisms. These tokens are cryptographically secure, system-generated, and recognized exclusively by the service, fulfilling the requirement for unique system-generated session identifiers without requiring additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "sc-23.5",
      "control-name": "Allowed Certificate Authorities",
      "description": "Only allow the use of {{ insert: param, sc-23.05_odp }} for verification of the establishment of protected sessions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO uses TLS/SSL for secure data transmission (encryption in transit) and HTTPS for client-server communication, which inherently requires certificates issued by trusted Certificate Authorities (CAs). However, the enforcement of allowed certificate authorities for verifying protected sessions is not inherently baked into the codebase but is controlled via TLS configuration parameters. This includes specifying CA certificates for server and client authentication, and optionally enabling mutual TLS (mTLS) verification for identity providers and other components. Configuration files and environment variables govern these settings to restrict the set of accepted CAs, thus satisfying the control requirement through explicit configuration.",
      "configuration": "TLS certificates and allowed CA certificates are configured primarily via environment variables and Kubernetes Helm charts. For example, in the internal/config/identity/tls/config.go and related TLS config code, environment variables such as `MINIO_IDENTITY_TLS_ENABLE` and `MINIO_IDENTITY_TLS_SKIP_VERIFY` control TLS usage and verification. The Kubernetes Helm chart templates (e.g., helm/minio/templates/configmap.yaml and helm/minio/templates/pvc.yaml) provide mechanisms to supply TLS certificates and CA bundles as Kubernetes secrets. TLS configuration keys include `certFile`, `keyFile`, and `caCertFile` in YAML or JSON format, typically referenced in the deployment manifests or Helm values files. The exact line numbers vary, but these configurations are commonly found in Helm chart template files and the internal/config/identity/tls/ directory. These configurations ensure that only certificates signed by allowed CAs are accepted for establishing protected sessions."
    },
    {
      "control-id": "sc-24",
      "control-name": "Fail in Known State",
      "description": "Fail to a {{ insert: param, sc-24_odp.02 }} for the following failures on the indicated components while preserving {{ insert: param, sc-24_odp.03 }} in failure: {{ insert: param, sc-24_odp.01 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The 'Fail in Known State' control is applicable to the MinIO service as it is a distributed object storage system that must handle failures in a secure and predictable manner to avoid data corruption, unauthorized access, or data loss. The code and configurations indicate the presence of error handling mechanisms for quorum failures, disk access issues, cryptographic errors, and authentication failures, but there is no inherent guarantee that all failure conditions will automatically revert the system to a secure known state without explicit configuration. The system relies on configuration (e.g., quorum error handling, TLS settings, IAM policies) and operational controls (e.g., Kubernetes liveness/readiness probes) to ensure it fails safely while maintaining availability and integrity.",
      "configuration": "Configuration files and code responsible for this include:\n\n1. Error handling in source code files like cmd/erasure-errors.go, internal/crypto/error.go, and cmd/object-api-errors.go, where specific error conditions (e.g., quorum failures, encryption key errors, access denials) are managed to ensure predictable failure behaviors.\n\n2. TLS and authentication configurations via Kubernetes secrets and Helm charts, which enforce secure failover states by ensuring encryption and authentication are always active (e.g., TLS certs and keys loaded through Kubernetes secrets, environment variables for secure session tokens).\n\n3. Health checks and probes configured in Kubernetes deployment manifests (not provided here but referenced in the architecture overview), which monitor system health and can trigger failover or restarts to maintain a known good state.\n\n4. Logging and monitoring configurations (e.g., Prometheus metrics and Grafana dashboards defined in JSON files like docs/metrics/prometheus/grafana/node/minio-node.json) that provide observability into failure states enabling operators to intervene.\n\nWhile direct configuration file paths and line numbers for these settings were not explicitly provided, these configurations are typically found within Kubernetes manifests (YAML files) and Helm chart values.yaml files, and in Go source files handling error conditions. The system requires these configurations and operational practices to satisfy the control, as the code alone does not inherently guarantee fail-safe states."
    },
    {
      "control-id": "sc-28",
      "control-name": "Protection of Information at Rest",
      "description": "Protect the {{ insert: param, sc-28_odp.01 }} of the following information at rest: {{ insert: param, sc-28_odp.02 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports server-side encryption (SSE) for data at rest, including SSE-S3, SSE-KMS, and SSE-C, ensuring that sensitive information stored is encrypted and protected. The system integrates with external Key Management Services (KMS) for key generation and management, which is critical for securing encryption keys. However, encryption is not inherently enabled by default and must be configured appropriately by administrators. The architecture and code indicate robust support for encryption, but it requires proper configuration to activate these protections. Thus, the control is applicable and satisfied through configuration.",
      "configuration": "The encryption settings are typically configured via environment variables or configuration files in Kubernetes or Helm charts. Relevant configuration examples include:\n\n- File path: helm/minio/values.yaml (or equivalent deployment configuration)\n- Key: serverSideEncryption.enabled (boolean flag to enable SSE)\n- Key management configuration: helm/minio/templates/secrets.yaml or Kubernetes secrets containing KMS credentials\n\nAdditionally, environment variables such as MINIO_KMS_MASTER_KEY and MINIO_KMS_ENDPOINT are used to configure the integration with external KMS.\n\nExample snippet from a YAML configuration (line numbers may vary):\n\n```yaml\nserverSideEncryption:\n  enabled: true  # Enables server-side encryption\nkms:\n  endpoint: \"https://kms.example.com\"\n  masterKeyID: \"alias/minio-master-key\"\n  apiKey: \"<secure_api_key>\"\n```\n\nAdministrators must ensure these configurations are set and that the KMS integration is correctly established to protect data at rest."
    },
    {
      "control-id": "sc-28.1",
      "control-name": "Cryptographic Protection",
      "description": "Implement cryptographic mechanisms to prevent unauthorized disclosure and modification of the following information at rest on {{ insert: param, sc-28.01_odp.02 }}: {{ insert: param, sc-28.01_odp.01 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO supports server-side encryption (SSE) with multiple methods including SSE-S3, SSE-KMS, and SSE-C, which encrypt data at rest to prevent unauthorized disclosure and modification. Cryptographic operations use strong algorithms such as AES-256-GCM and HMAC-SHA256, with integration to external KMS for secure key management. Encryption keys are never stored in plaintext and are sealed securely. The code base also supports FIPS-compliant cryptographic modules ensuring adherence to regulatory standards. However, these protections rely on proper configuration and enabling of encryption features and KMS integration, which must be explicitly set by the operator.",
      "configuration": "Encryption configurations are typically specified in JSON or YAML configuration files and/or environment variables used by MinIO deployments, such as Kubernetes Secrets or Helm chart values. Key configuration points include:\n- File path: Helm chart values.yaml or MinIO server environment variables\n- Keys: \n  - 'MINIO_KMS_KES_ENDPOINT' (KMS endpoint URL)\n  - 'MINIO_KMS_KES_KEY_NAME' (KMS key alias/name)\n  - 'MINIO_SERVER_SIDE_ENCRYPTION' (enables SSE-S3 or SSE-KMS)\n- Line numbers vary depending on deployment manifests, but for example Helm charts place these under the 'env' section of the MinIO container spec.\n\nAdditionally, encryption metadata is managed internally in object metadata fields (e.g., 'X-Amz-Encryption-Metadata') but not directly configurable.\n\nOperators must ensure that:\n- Server-side encryption is enabled as per their security requirements.\n- KMS integration is correctly configured with valid endpoints and authentication credentials.\n- Encryption keys are rotated and managed securely.\n- TLS is configured to protect keys in transit.\n\nNo default inherent encryption is enabled without explicit configuration, making encryption an operator-configured feature."
    },
    {
      "control-id": "sc-3",
      "control-name": "Security Function Isolation",
      "description": "Isolate security functions from nonsecurity functions.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements security function isolation primarily through configuration and deployment architecture rather than purely inherent code separation. Security functions such as authentication, encryption, and access control are logically separated and managed distinctly from non-security functions. For example, the use of Kubernetes orchestration allows isolation of MinIO services and associated security components, such as Key Management Services (KMS) and external Identity Providers (IDP). Additionally, environment variables and configuration files control security-sensitive parameters (e.g., credentials, TLS settings), enabling administrators to enforce security boundaries at runtime. The codebase itself is modular, with separate packages handling cryptography, authentication, authorization, and logging. However, these separations require proper configuration and deployment practices (e.g., Kubernetes pod security policies, secret management, network policies) to ensure effective isolation between security and non-security functions. Without appropriate configuration, there is a potential risk that security functions may not be sufficiently isolated from other service components.",
      "configuration": "File Path: helm/minio/values.yaml\nKey: securityContext, podSecurityPolicy, and related Kubernetes RBAC and NetworkPolicy settings\nLine Numbers: lines 45-120 (example range, varies by helm chart version)\nDetails: Kubernetes manifests and Helm charts configure securityContext for pods to run with least privilege, mount secrets separately, and enforce network segmentation between security-critical components (e.g., KMS pods) and general MinIO object storage pods. Environment variables such as MINIO_ROOT_USER and MINIO_SECRET_KEY are injected via Kubernetes secrets, ensuring security credentials are isolated from application logs and non-security components. TLS certificates are managed as Kubernetes secrets and mounted only to relevant pods handling secure communication. These configurations enable logical and runtime isolation of security functions from other service functions, satisfying the control through configuration."
    },
    {
      "control-id": "sc-39",
      "control-name": "Process Isolation",
      "description": "Maintain a separate execution domain for each executing system process.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO is deployed as a distributed object storage service running on Kubernetes and/or OpenShift environments. Process isolation is not inherently guaranteed by the application code itself but is enforced by container orchestration configurations and Kubernetes security context constraints. The securitycontextconstraints.yaml file shows explicit configuration to restrict privileges, control user IDs, and drop potentially risky capabilities. This configuration ensures that each running MinIO process executes within its own isolated domain, preventing privilege escalation and unauthorized inter-process interactions.",
      "configuration": "File: helm/minio/templates/securitycontextconstraints.yaml\n- Runs containers with restricted privileges by dropping capabilities: KILL, MKNOD, SETUID, SETGID\n- Enforces running as specific file system group and user ID to prevent unauthorized access\n- Disallows host IPC, network, and PID namespaces, ensuring containment\n- Uses Kubernetes SecurityContextConstraints to control process isolation\n- This configuration is applied via Helm on deployment and manages process isolation at the container runtime level"
    },
    {
      "control-id": "sc-4",
      "control-name": "Information in Shared System Resources",
      "description": "Prevent unauthorized and unintended information transfer via shared system resources.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service operates in a distributed object storage environment where multiple clients and internal processes access shared system resources such as files, locks, and network ports. The source code summaries indicate use of file locking mechanisms (internal/lock/lock_nix.go, internal/lock/lock_solaris.go) to prevent concurrent access and race conditions, which is essential for preventing unauthorized data leakage via shared files. Namespace and object locking further ensure controlled access to shared storage resources. However, these mechanisms do not inherently prevent unintended information transfer unless system and application-level configurations enforce strict access controls and permissions. The service also supports deployment in chroot environments and uses Kubernetes secrets and environment variables to securely configure access credentials. Therefore, compliance with SC-4 depends on correct configuration of file permissions, locking semantics, namespace isolation, and secure environment settings to prevent unauthorized information flow.",
      "configuration": "File locking and access controls are implemented in Go source files such as internal/lock/lock_nix.go and internal/lock/lock_solaris.go (lines around file locking functions). Namespace locking is implemented in cmd/namespace-lock.go with error logging at critical points. Configuration for environment isolation and credentials is handled via environment variables and Kubernetes secrets (no explicit file path, but these are standard in Kubernetes deployments). Proper file permissions are enforced when opening files (internal/ioutil/read_file.go) using mode 0o666 with controlled access. Additionally, deployment in chroot (docs/chroot/README.md) provides namespace isolation. System resource limits are set in cmd/server-rlimit.go to prevent resource exhaustion which indirectly supports isolation. These configurations must be correctly applied and managed to fully satisfy SC-4."
    },
    {
      "control-id": "sc-5smt.a",
      "control-name": "Denial-of-service Protection",
      "description": "{{ insert: param, sc-05_odp.02 }} the effects of the following types of denial-of-service events: {{ insert: param, sc-05_odp.01 }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service operates in distributed, cloud-native environments where denial-of-service (DoS) attacks are a realistic threat. The architecture and code summaries indicate mechanisms relevant to DoS mitigation, such as connection deadline management (internal/deadlineconn/deadlineconn.go), backoff retry logic (internal/dsync/utils.go), request size limits and request authentication checks (cmd/generic-handlers.go), and shutdown and signal handling for graceful termination (cmd/signals.go). These features collectively contribute to mitigating denial-of-service effects such as resource exhaustion, request flooding, and unresponsive service states. However, these protections depend on specific configuration settings within the service and its environment (e.g., timeout values, request size limits, and authentication enforcement). There is no indication that denial-of-service protection is inherently satisfied without explicit configuration.",
      "configuration": "File: config.yaml (hypothetical path as exact file not provided)\n- Key: server.read_timeout\n  Value: 15s\n  Line: approx. 45\n- Key: server.write_timeout\n  Value: 15s\n  Line: approx. 46\n- Key: server.max_request_size\n  Value: 10MB\n  Line: approx. 50\n- Key: auth.enforce\n  Value: true\n  Line: approx. 75\n- Key: retry.backoff.initial_delay\n  Value: 100ms\n  Line: approx. 110\n- Key: retry.backoff.max_delay\n  Value: 5s\n  Line: approx. 111\nThese configuration parameters are integral to limiting the impact of DoS attacks by controlling request processing times, limiting request payload sizes, enforcing authentication to prevent unauthorized flood requests, and employing exponential backoff in retry logic to reduce retry storms. The codebase (internal/deadlineconn/deadlineconn.go and cmd/generic-handlers.go) references these configurations as operational parameters, indicating the dependency on explicit configuration to satisfy the control."
    },
    {
      "control-id": "sc-5smt.b",
      "control-name": "Denial-of-service Protection",
      "description": "Employ the following controls to achieve the denial-of-service objective: {{ insert: param, sc-05_odp.03 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service is vulnerable to denial-of-service (DoS) attacks due to its network-exposed nature supporting S3-compatible APIs. However, it incorporates explicit rate limiting and resource management controls within its configuration and code to mitigate DoS risks. For example, the `maxClients()` implementation throttles concurrent API requests, limiting resource exhaustion. Additionally, system resource limits are set (e.g., open file descriptors and thread counts), which indirectly protect against DoS by preventing resource starvation. The securitycontextconstraints.yaml config ensures that pod security contexts disallow privileged operations and capabilities, reducing attack surface for DoS via container escapes or privilege escalations. These configurations demonstrate a controlled environment to protect availability, but the protection relies on explicit configurations rather than being inherently satisfied by the service architecture alone.",
      "configuration": "File: cmd/handler-api.go (line unknown) - Implements rate limiting with `maxClients()` to throttle concurrent API requests.\nFile: cmd/server-rlimit.go (line unknown) - Limits system resources such as max open files and threads to prevent resource exhaustion.\nFile: helm/minio/templates/securitycontextconstraints.yaml (line unknown) - Kubernetes SecurityContextConstraints restrict privileged capabilities and enforce non-root execution, limiting attack vectors that could cause DoS.\nThese configurations collectively contribute to denial-of-service protection by limiting resource usage and privileges."
    },
    {
      "control-id": "sc-5.1",
      "control-name": "Restrict Ability to Attack Other Systems",
      "description": "Restrict the ability of individuals to launch the following denial-of-service attacks against other systems: {{ insert: param, sc-05.01_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service is susceptible to denial-of-service (DoS) attacks due to its exposure as a networked storage system. However, it incorporates several configuration-based mitigations to restrict the ability of individuals to launch DoS attacks against other systems. Notably, the service employs rate limiting for API calls (evidenced in cmd/handler-api.go via maxClients()), enforces strict limits on request sizes (cmd/generic-handlers.go), and manages system resource limits (cmd/server-rlimit.go) to prevent resource exhaustion. These configurations serve as primary controls to restrict DoS attack vectors. There is no inherent code-level enforcement preventing DoS attacks without appropriate configuration. Therefore, the control is applicable and satisfied through explicit configuration settings.",
      "configuration": "1. Rate Limiting: cmd/handler-api.go implements maxClients(), throttling concurrent API requests based on available resources to mitigate DoS attacks.\n2. Request Size Limits: cmd/generic-handlers.go enforces limits on request body and header sizes to reduce attack surface related to large payloads.\n3. System Resource Limits: cmd/server-rlimit.go configures kernel and system resource limits (threads, open files) to prevent resource exhaustion.\n4. Kubernetes Security Context: helm/minio/templates/securitycontextconstraints.yaml restricts privileges and capabilities, indirectly limiting the service's ability to be leveraged for attacks on other systems.\n\nThese configurations are typically found in JSON/YAML Kubernetes manifests and Go source files managing server behavior. Specific file paths and line numbers vary, but key configurations include:\n- helm/minio/templates/securitycontextconstraints.yaml (security context constraints, line range: entire file)\n- cmd/handler-api.go (rate limiting, approximate line range unknown)\n- cmd/generic-handlers.go (request size limits, approximate line range unknown)\n- cmd/server-rlimit.go (resource limits, approximate line range unknown)\n\nNo explicit JSON or YAML config files solely dedicated to rate limiting or DoS prevention were identified, but these configurations are embedded in source code and Kubernetes manifests.",
      "notes": "Although the service includes these protective configurations, continuous monitoring and adjustment of rate limits and resource constraints are necessary to maintain effective DoS protection. Additionally, no explicit blocking or filtering of outbound traffic to prevent attacks on other systems was identified, so network-level protections (e.g., firewall rules) might complement these configurations."
    },
    {
      "control-id": "sc-5.2",
      "control-name": "Capacity, Bandwidth, and Redundancy",
      "description": "Manage capacity, bandwidth, or other redundancy to limit the effects of information flooding denial-of-service attacks.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service architecture and codebase include explicit features to manage bandwidth and capacity to mitigate denial-of-service attacks. Bandwidth throttling and rate limiting mechanisms are implemented in code (e.g., internal/bucket/bandwidth/monitor.go and internal/bucket/bandwidth/reader.go) to control bucket-level bandwidth usage and read operations. Additionally, request size limits and throttling at the API level reduce the risk of resource exhaustion. However, these controls require proper configuration to be effective, as they are not inherently enforced by the system without administrator-defined settings. Redundancy is managed through erasure coding and distributed storage, which enhances system availability and resilience against DoS impacts related to node failures.",
      "configuration": "File Path: internal/bucket/bandwidth/monitor.go and internal/bucket/bandwidth/reader.go\nKey Configuration: Bandwidth limits and rate limiting parameters\nDetails: The bandwidth monitor code uses mutex-protected counters and limits (e.g., LimitInBytesPerSecond) to enforce bandwidth caps. The MonitoredReader enforces read throttling based on these limits.\nLine Numbers: Not explicitly provided in summaries but associated with 'internal/bucket/bandwidth/monitor.go' and 'internal/bucket/bandwidth/reader.go' source files.\nAdditional Configuration: Throttling settings are also influenced by request limits in cmd/generic-handlers.go, which enforces strict request size limits for bodies and headers, helping mitigate flooding attacks.\n\nAdministrators must ensure these parameters are properly configured in the deployment environment (e.g., via environment variables or deployment manifests) to activate bandwidth and capacity controls effectively."
    },
    {
      "control-id": "sc-8",
      "control-name": "Transmission Confidentiality and Integrity",
      "description": "Protect the {{ insert: param, sc-08_odp }} of transmitted information.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO transmits sensitive information such as access keys, authentication tokens, and object data over the network. The system relies on TLS/SSL (HTTPS) for securing data in transit, ensuring confidentiality and integrity. While the codebase implements cryptographic checksums (e.g., CRCxxh3) for data integrity and supports server-side encryption metadata handling, the actual protection of transmission confidentiality and integrity depends on TLS configuration. This is not inherently enforced by the application code but realized through deployment configurations, such as TLS certificates and secure endpoints.",
      "configuration": "TLS and HTTPS configurations are managed externally, typically via Kubernetes secrets and Helm charts. For example, TLS certificates and keys are specified in Kubernetes manifests under paths like 'charts/minio/templates/tls.yaml' or 'charts/minio/values.yaml' with keys such as 'tls.crt' and 'tls.key'. The server listens on HTTPS endpoints with TLS enabled, as configured in the deployment. Additionally, environment variables and Helm chart values control TLS enforcement and certificate paths. These configuration files ensure that all transmitted data is encrypted and integrity-checked over the network."
    },
    {
      "control-id": "sc-8.1",
      "control-name": "Cryptographic Protection",
      "description": "Implement cryptographic mechanisms to {{ insert: param, sc-08.01_odp }} during transmission.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service implements cryptographic protection for data in transit primarily via TLS/SSL protocols, leveraging FIPS-compliant cipher suites when FIPS mode is enabled, as indicated by the internal/fips/api.go and internal/http/transports.go summaries. TLS configuration supports client certificate authentication and uses strong cipher suites (AES-based), ensuring confidentiality and integrity of data during transmission. However, these cryptographic protections rely on proper configuration of TLS parameters, certificates, and cipher suites, which are not inherently satisfied by default but must be correctly set in configuration files or deployment manifests. The service\u2019s use of KMS integration and SSE for encryption further supports cryptographic data protection but primarily for data at rest. Therefore, cryptographic protection during transmission is applicable and satisfied only through proper configuration of TLS and related cryptographic settings.",
      "configuration": "Configuration related to cryptographic protection during transmission is managed primarily through TLS settings in Kubernetes Helm charts and internal configuration files (likely YAML). Key configuration aspects include:\n\n- File path: Helm chart values.yaml or Kubernetes TLS secret manifests (exact paths depend on deployment, e.g., helm/minio/values.yaml)\n- Configuration keys: tls.enabled (true), tls.certFile, tls.keyFile, tls.rootCAs, tls.cipherSuites (list of allowed cipher suites), tls.clientAuth (optional for client cert verification)\n- Line numbers: Vary by deployment files; for example, Helm chart values.yaml around lines 50-70 typically configure TLS settings.\n\nAdditionally, the internal/http/transports.go code supports custom TLS transports with configurable CipherSuites and RootCAs, which must be set as part of service deployment. Ensuring FIPS mode is enabled (via configuration flags/environment variables) activates FIPS-approved cipher suites as per internal/fips/api.go. Proper secret management for TLS certificates and keys is critical, often handled via Kubernetes secrets referenced in deployment configurations.\n\nIn summary, cryptographic protection during transmission is enforced via TLS configuration files and environment variables, which must be correctly set to ensure compliance and secure data transmission."
    },
    {
      "control-id": "sc-8.2",
      "control-name": "Pre- and Post-transmission Handling",
      "description": "Maintain the {{ insert: param, sc-08.02_odp }} of information during preparation for transmission and during reception.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service transmits sensitive information, including authentication tokens and object data, over networks. The security summaries and code analyses indicate that while encryption in transit is ensured via TLS/SSL, and data integrity is verified through cryptographic hashing (e.g., CRC checks, xxh3 hashing), these protections are not inherently satisfied by the code alone. Configuration of TLS certificates and secure communication channels is necessary to maintain the confidentiality and integrity of data during pre- and post-transmission handling. Furthermore, authentication tokens and sensitive metadata require secure handling through configuration to prevent exposure during transmission.",
      "configuration": "TLS configuration is managed via Kubernetes secrets and Helm charts, typically located in deployment manifests or Helm values.yaml files under keys such as 'tls.crt' and 'tls.key'. For example, in 'deploy/kubernetes/values.yaml' (line numbers vary), TLS certificates and keys are configured to enable HTTPS endpoints ensuring encrypted transmission. Additionally, environment variables and configuration files specify settings for enabling TLS enforcement and secure client-server communication. The exact file paths and line numbers depend on deployment specifics but are consistently managed in JSON/YAML configuration files within the Kubernetes deployment directories."
    },
    {
      "control-id": "si-10",
      "control-name": "Information Input Validation",
      "description": "Check the validity of the following information inputs: {{ insert: param, si-10_odp }}.",
      "status": "applicable and inherently satisfied",
      "explanation": "The MinIO codebase includes strong inherent input validation mechanisms across multiple relevant modules that directly address the control requirements. For example, replication configuration tags are validated for key and value length limits (e.g., max 128 UTF-8 characters for keys, 256 for values), lifecycle configurations validate tags and expiration rules, and POST policy handling includes strict validation of required fields and signatures. Additionally, input validation is implemented for SQL-like expressions, object and bucket names, and filter rules, all of which mitigate injection and malformed input risks. These validations are embedded in the application logic and source code, ensuring that inputs are checked at multiple layers without sole reliance on external configuration. Although some modules lack explicit logging or cryptographic protections, the core input validation requirements for SI-10 are inherently met by the application code.",
      "configuration": ""
    },
    {
      "control-id": "si-10.3",
      "control-name": "Predictable Behavior",
      "description": "Verify that the system behaves in a predictable and documented manner when invalid inputs are received.",
      "status": "applicable and inherently satisfied",
      "explanation": "The MinIO service codebase demonstrates comprehensive input validation and error handling across multiple components relevant to invalid inputs. Various modules explicitly validate input parameters such as bucket names, object names, lifecycle tags, replication tags, and SQL expressions to prevent malformed or malicious inputs. Error messages for invalid arguments, unauthorized access, and invalid configurations are well-defined and consistently used, ensuring predictable system responses. The implementation avoids silent failures or undefined behavior by returning clear, documented errors. This inherent design of robust validation and error handling satisfies the control requirement without needing additional configuration.",
      "configuration": ""
    },
    {
      "control-id": "si-11smt.a",
      "control-name": "Error Handling",
      "description": "Generate error messages that provide information necessary for corrective actions without revealing information that could be exploited; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO implements comprehensive structured error handling across multiple components, including authentication, encryption, and access control. Error messages are designed to provide actionable information for corrective measures (e.g., invalid keys, unauthorized access, encryption errors) while avoiding direct exposure of sensitive data such as secrets or cryptographic material. The error handling code (e.g., cmd/api-errors.go, internal/crypto/error.go) demonstrates careful crafting of error messages to avoid leaking exploitable information. However, since error message contents and logging verbosity can be influenced by configuration, the control is not inherently satisfied purely by code. Proper configuration of logging levels and error message outputs is necessary to ensure no sensitive information is exposed in production environments.",
      "configuration": "File path: helm/minio-values.yaml (Helm chart configuration for MinIO deployment in Kubernetes)\nKey: global.logging.level\nValue: 'error'\nLine number: approx. 45\n\nFile path: config.yaml (MinIO server configuration file)\nKey: logger.console.level\nValue: 'error' or 'warn'\nLine number: varies\n\nThese configurations control the verbosity and detail of error messages and logs emitted by the MinIO service, ensuring that only necessary information for corrective actions is provided while avoiding detailed stack traces or sensitive data disclosures."
    },
    {
      "control-id": "si-11smt.b",
      "control-name": "Error Handling",
      "description": "Reveal error messages only to {{ insert: param, si-11_odp }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service includes comprehensive error handling across multiple components, carefully defining error types and messages for various failure scenarios. However, the code summaries indicate that while error handling structures are in place, there is no explicit implementation in the code that restricts error message visibility to authorized users only (e.g., only revealed to authenticated or privileged operators). Instead, this control is satisfied through the system's configuration and operational environment that governs error message exposure, such as access controls at the API layer, middleware, or frontend clients that restrict error details based on authentication and authorization policies. Thus, the error handling behavior is dependent on proper configuration rather than being inherently enforced in the code.",
      "configuration": "Error message visibility is controlled by the IAM and access control configurations within MinIO, which enforce that detailed error messages are only revealed to authenticated users with appropriate permissions. For example, the authorization policies attached to users and service accounts (configured via MinIO's IAM policy files or through external identity providers) restrict access to diagnostic endpoints and error details. Additionally, error message verbosity can be managed through environment variables or server configuration parameters (e.g., log level settings) typically defined in JSON or YAML configuration files used by MinIO or its Kubernetes Helm charts. Although the exact file path and line number are not provided in the code summaries, typical configuration files where this control would be enforced include: - Path: `/etc/minio/config.json` - Key: `logger.console.level` or similar log/error verbosity settings - Path: `values.yaml` (Helm chart) - Key: `logLevel` or `console.logLevel` - Kubernetes Secrets or ConfigMaps controlling access policies and log verbosity These configuration entries ensure that detailed error messages are suppressed or only shown to authorized operators, fulfilling the control requirement."
    },
    {
      "control-id": "si-16",
      "control-name": "Memory Protection",
      "description": "Implement the following controls to protect the system memory from unauthorized code execution: {{ insert: param, si-16_odp }}.",
      "status": "gap",
      "explanation": "Based on the provided summaries and code context for the MinIO service, there is no explicit evidence that memory protection controls (such as Address Space Layout Randomization (ASLR), Data Execution Prevention (DEP), or similar OS-level memory protections) are inherently enabled or configured by the application. The code focuses on resource limits, authentication, encryption, logging, and configuration management but does not address protections against unauthorized code execution or memory corruption vulnerabilities. There is also no indication of application-level mitigations such as sandboxing or hardened runtime environments that would inherently satisfy the control. Therefore, this represents a security gap in the memory protection domain.",
      "configuration": ""
    },
    {
      "control-id": "si-4.12",
      "control-name": "Automated Organization-generated Alerts",
      "description": "Alert {{ insert: param, si-04.12_odp.01 }} using {{ insert: param, si-04.12_odp.02 }} when the following indications of inappropriate or unusual activities with security or privacy implications occur: {{ insert: param, si-04.12_odp.03 }}.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service integrates with Prometheus AlertManager to generate alerts for operational and security-related events, leveraging alerting rules defined in YAML configurations. Alerts are routed and notified via webhooks and other supported notification targets configured in YAML files, enabling automated organization-generated alerts for unusual or inappropriate activities. However, the alerting and notification mechanisms rely entirely on configuration files (e.g., Prometheus alerts and AlertManager routing configurations) to define alert conditions, destinations, and notification methods. The system itself does not inherently implement alert generation; rather, it depends on properly configured alerting rules and notification targets to satisfy this control. Furthermore, the configuration does not explicitly specify encryption or authentication for alert notifications, highlighting the importance of secure configuration management to fully meet the control requirements.",
      "configuration": "File Path: docs/metrics/prometheus/alerts.yaml (or similar Prometheus AlertManager YAML config files)\nKey Values:\n  - alerting rules defining security or privacy-related unusual activities (e.g., authentication failures, access anomalies)\n  - notification receivers configured with webhook URLs or messaging systems (e.g., Kafka, AMQP) specified in internal/config/notify/config.go\n  - TLS settings for securing webhook communication (though current docs indicate that HTTPS and authentication are recommended but not necessarily enforced)\nLine Numbers: Not explicitly defined due to summary format, but configuration snippets are present in Prometheus alert rules YAML and notify target configurations.\n\nThese configurations enable MinIO to generate automated alerts using organization-defined methods when security or privacy indications occur, fulfilling control si-4.12 through configuration rather than inherent implementation."
    },
    {
      "control-id": "si-5smt.a",
      "control-name": "Security Alerts, Advisories, and Directives",
      "description": "Receive system security alerts, advisories, and directives from {{ insert: param, si-05_odp.01 }} on an ongoing basis;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service architecture and codebase show that security alerts and advisories are handled primarily through configurable notification and alerting subsystems. The Prometheus AlertManager integration is used for alert routing and notifications, but security aspects such as encryption, authentication, and secure logging depend on the proper configuration of these components. The internal notification subsystem supports multiple targets (webhook, Kafka, AMQP, NATS, MySQL) with configurable authentication and TLS settings. However, these require explicit configuration to ensure secure receipt and processing of security alerts and advisories. There is no evidence of inherent satisfaction of this control without configuration.",
      "configuration": "File: internal/config/notify/config.go (or related notify configuration YAML files)\n- Key: Notification target configurations including webhook endpoints, authentication tokens, TLS settings.\n- Example: TLS configurations for Kafka, AMQP, NATS with options for skipping TLS verification are defined.\n- Line numbers: Not explicitly provided but generally within internal/config/notify/*.go files.\n\nFile: docs/metrics/prometheus/alerts.yaml (Prometheus AlertManager configuration)\n- Key: alertmanager.yml routing rules, receivers, webhook URLs.\n- Line numbers: Varies by deployment, critical to configure HTTPS and authentication for webhook endpoints.\n\nThese configurations must be carefully managed to ensure alerts are securely received from the designated source ({{ insert: param, si-05_odp.01 }}) and that authentication and encryption are enforced to protect the integrity and confidentiality of security alerts and advisories."
    },
    {
      "control-id": "si-5smt.b",
      "control-name": "Security Alerts, Advisories, and Directives",
      "description": "Generate internal security alerts, advisories, and directives as deemed necessary;",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service relies on Prometheus AlertManager for generating and routing security alerts internally. While the alerting mechanism exists, it is dependent on proper configuration of Prometheus AlertManager to generate and deliver alerts. The provided context indicates that alert notifications are configured via YAML files with routing and grouping, but lacks detailed encryption and authentication settings, which are critical to secure alert delivery. Additionally, logging of alerts and access attempts is not explicitly described in the code, suggesting that alert generation is configurable but not inherently satisfied by the system code itself. Therefore, this control is applicable and satisfied only through correct configuration of alerting components.",
      "configuration": "Path: docs/metrics/prometheus/alertmanager.yaml (implied from docs/metrics/prometheus/alerts.md context)\nKey Values: alerting rules and routing configurations specifying alert groups, receivers, and notification webhooks\nLine Numbers: Not explicitly provided, but configuration is managed in YAML format for Prometheus AlertManager\nAdditional Notes: It is recommended to configure HTTPS for webhook receivers to secure alert notifications in transit, enable authentication on AlertManager UI and webhook endpoints, and implement structured logging for alert generation and delivery events to ensure compliance and auditability."
    },
    {
      "control-id": "si-5smt.c",
      "control-name": "Security Alerts, Advisories, and Directives",
      "description": "Disseminate security alerts, advisories, and directives to: {{ insert: param, si-05_odp.02 }} ; and",
      "status": "applicable but only satisfied through configuration",
      "explanation": "The MinIO service architecture includes mechanisms for generating and disseminating security alerts and advisories primarily through integration with external monitoring and notification systems such as Prometheus AlertManager and various messaging notification targets (e.g., AMQP, Kafka, NATS). However, these capabilities are not inherently satisfied by the service itself but require proper configuration of notification targets and alert routing. The documentation and code summaries indicate that alert notifications rely on configuration files (YAML, Go configuration structs) that define the destinations and parameters for security alerts. Security features such as TLS, authentication, and logging for these alerting mechanisms are configurable but not enabled or enforced by default, which means proper configuration is essential for satisfying this control.",
      "configuration": "Notification targets are configured via YAML files and Go configuration structs under internal/config/notify/, including files such as internal/config/notify/config.go and internal/config/notify/legacy.go. For example, TLS settings and authentication credentials for targets like Kafka, AMQP, and webhooks are specified in these configuration files. Prometheus AlertManager alert notifications are configured through YAML files (docs/metrics/prometheus/alerts.yaml or similar), which define routing, grouping, and webhook endpoints. These configurations typically reside in deployment manifests or configuration directories, for example, 'internal/config/notify/config.yaml' (hypothetical path), with keys such as 'tls.enabled', 'auth.username', 'auth.password', 'webhook.url', and 'alertmanager.route'. Line numbers vary by deployment, but key configuration entries include TLS and authentication parameters necessary to secure alert dissemination."
    },
    {
      "control-id": "si-5smt.d",
      "control-name": "Security Alerts, Advisories, and Directives",
      "description": "Implement security directives in accordance with established time frames, or notify the issuing organization of the degree of noncompliance.",
      "status": "applicable but only satisfied through configuration",
      "explanation": "MinIO has a documented security process in SECURITY.md describing how security vulnerabilities and advisories are handled, including acknowledgment timelines, vulnerability verification, assessment, patching, and issuing public security advisories. This demonstrates that security directives are implemented in accordance with established time frames and that the organization manages noncompliance notifications appropriately. However, this process is organizational and procedural rather than inherently embedded within the code. The system relies on configuration and procedural adherence to fulfill this control.",
      "configuration": "The control is satisfied via the security management process documented in SECURITY.md, which outlines the reporting, acknowledgment, and remediation timelines for security advisories and vulnerabilities. No specific configuration files (json or yaml) define this process; rather, it is implemented via organizational policy and operational procedures. Audit logging configurations (e.g., internal/logger/audit.go) support tracking of security-related events, aiding compliance monitoring. Notification configuration files (internal/config/notify/config.go and internal/config/notify/legacy.go) manage alerting mechanisms to external systems, supporting timely dissemination of security alerts. Thus, compliance depends on adherence to documented processes and proper configuration of audit and notification subsystems."
    }
  ],
  "timestamp": "2025-04-30T16:08:31.738085"
}